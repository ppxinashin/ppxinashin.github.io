[{"content":"","date":"2024-11-28","externalUrl":null,"permalink":"/golang/","section":"Golangs","summary":"","title":"Golangs","type":"golang"},{"content":"","date":"2024-11-28","externalUrl":null,"permalink":"/","section":"热河fen青","summary":"","title":"热河fen青","type":"page"},{"content":" 面试题 # 自我介绍 项目介绍 MySQL 知识点 场景设计-短链接(30 min)，插入、查询 Java 知识点 Go 知识点 代码题 最长字串，leetcode原题，滑动窗口 ","date":"2024-11-28","externalUrl":null,"permalink":"/golang/interview/wits-od-baidu/","section":"Golangs","summary":"","title":"纬创外派-百度网盘项目-go语言","type":"golang"},{"content":"","date":"2024-11-28","externalUrl":null,"permalink":"/java/","section":"Javas","summary":"","title":"Javas","type":"java"},{"content":" 面试题 # 自我介绍 - 要求候选人简述自己的背景和经历。 样例：尊敬的面试官，您好。我是XXX，一名拥有2年Java后端开发经验的工程师。最近在XX公司担任后端工程师，主导了多个关键项目的开发与优化。我对Java有深入理解，熟悉集合类、自定义注解及异常处理，并严格遵守阿里编码规范确保代码质量。熟练使用SSM和Spring Boot框架，曾用MyBatis-Plus提升开发效率。掌握了Redis的应用与优化，解决了缓存穿透、一致性问题，并通过Lua脚本实现限流。特别值得一提的是，在构建一个在线答题平台时，我利用Spring Boot整合了Redis缓存、通义AI智能服务、RxJava响应式编程以及SSE实时推送技术。我们团队采用了策略模式提高系统灵活性，封装AI服务简化初始化，优化Prompt保证数据格式化，同时引入Caffeine本地缓存减少重复计算，显著提升了系统性能。此外，我还领导了一次从Java到Go的技术迁移，大幅提高了开发效率并降低了维护成本。我对软件工程充满热情，持续追求技术水平和服务质量的提升。我相信我的背景和技术能力非常适合这个职位，期待能进一步讨论如何为贵公司带来价值。感谢您提供的机会，希望有幸加入贵公司。谢谢！ 项目介绍 - 让候选人详细讲述最近参与的项目，特别是与AI答题系统相关的内容。 继续看看课程，稍作完善 系统并发能力 - 询问智能答题系统的并发处理能力，特别是针对一万多用户的场景。 信口胡说一下，因为我把它包装成了一个高校特供的项目，当然之前有这样的项目 数据处理流程 - 关于答题系统中数据处理的具体流程，尤其是AI判题时的数据存储和检索机制。 不会 数据库索引 - 提问关于MySQL查询语句中使用IN关键字是否触发索引，以及联合索引的使用情况。 需结合实际情况讨论，仍以字段是否有索引为标准 索引下推 最左匹配原则 事务隔离级别 - 考察候选人对数据库事务隔离级别的理解，特别是MySQL的默认隔离级别及其含义。 四大隔离：读已提交、读未提交、可重复读、串行化 默认隔离级别：可重复读 含义：它确保在同一事务中多次读取同一数据集时，结果是一致的。这意味着在事务执行期间，其他事务无法修改这些数据。这个级别可以防止脏读和不可重复读，但可能出现幻读。 MySQL执行计划 - 询问候选人如何查看和解读MySQL的执行计划，用于查询优化。 select_type, type, key, key_len, rows, Extra 查询类型效率 - 讨论MySQL查询类型（如index, range, ref）的效率排序。 参考： ref \u0026gt; range \u0026gt; index const, system：这些查询类型用于单行匹配，效率最高。 eq_ref：用于唯一索引的查询，每次只返回一行。 ref：用于非唯一索引的查询，可能返回多行。 range：用于范围查询，扫描索引的一部分。 index：扫描整个索引。 ALL：全表扫描，效率最低。 测试候选人对Java字符串处理的理解，包括字符串相等性的判断（小场景题，主要是==与equals的区别） 参考：== equals 和 hashCode 是什么，又有怎样的区别？ 扩展问题： String/StringBuilder/StringBuffer的区别。 类加载顺序 - 询问Java中类的静态变量、静态代码块、成员变量、普通代码块、构造方法、(静态方法)的加载顺序。 静态变量和静态代码块 \u0026gt; 成员变量和普通代码块 \u0026gt; 构造方法 (\u0026gt; 静态方法) Java IO - 要求解释Java IO的不同模式，包括传统的阻塞IO、非阻塞IO及AIO，并提及项目中常用的字节流。 问你这个的时候，实际上考官在问的是序列化和反序列化问题 还有文件字节流 还有上面的三种io ","date":"2024-11-28","externalUrl":null,"permalink":"/java/interview/yss-od-icbc/","section":"Javas","summary":"","title":"赢时胜-外派工行面经","type":"java"},{"content":" 1. 自我介绍 # 面试解析：普通人面试指南2024版\n2. 问题回忆 # 介绍一下你拿手的项目？ 遇到的难点 RabbitMQ问题 MySQL事务问题 Java基础类型 深拷贝和浅拷贝 包装类型和值类型 包装类型和值类型属于什么拷贝 JDK 1.8 新特性 流相关问题 流的过滤会不会影响已有的数组 Spring IOC AOP是什么？ Bean注入是属于IOC还是AOP Spring事务问题（没答上来，瞎编引导到MyBatis） 3. 感受 # 这次感觉很社死，答得磕磕巴巴，差点我就要紫砂了，时至今日都没有一张offer.\n4. 假设通过 # 会有个二面，二面是关于写代码的事情，既然没通过就算了\n5. 如何解决心理问题 # 放松，啥也别想，大不了这辈子不工作，躺尸\n","date":"2024-11-28","externalUrl":null,"permalink":"/java/interview/hand-info-tech/","section":"Javas","summary":"","title":"汉得信息-一面凉经（回忆版）","type":"java"},{"content":" 0. 面试结果 # 岗位竞争激烈，只要两个人，凉凉\n1. 自我介绍 # 面试解析：普通人面试指南2024版\n2. 问题（30min+） # 什么是Spring事务 面向对象相关问题 RabbitMQ相关问题（重复、积压、防止丢失、有序性） Redis哨兵集群有关问题 MySQL事务隔离级别、版本并发控制相关问题 JDK1.8新特性 多线程、高并发 其他Spring相关问题 遇到困难的地方？ 自主提问 3. 感受 # HR小哥哥人还怪好叻~ 我出门的时候人家亲自按电梯，还提醒我注意安全啥的，初始印象还算不错\n但是人类嘛，人越是看似对你好，你一定要有所怀疑\n","date":"2024-11-28","externalUrl":null,"permalink":"/java/interview/tfry-basedl-sz/","section":"Javas","summary":"","title":"同方软银-base大连-深圳出长差-面试（单次/回忆版本）","type":"java"},{"content":" 0. 面试结果 # 凉凉，差点以为能过，面试官当时对我印象不错，意难平，决定分享\n1. 自我介绍(1min) # 面试解析：普通人面试指南2024版\n2. 项目相关描述(15min) # 提问点来自简历一部分内容，基本上都是在聊简历有关话题\n印象最深的就是为何不使用WebSocket，而是使用SSE？\n项目中，鱼皮的AI问答系统，我直接给包装成了公司项目，反正一个隐私问题，不允许泄密就可以糊弄过去，反正以前我司做过类似项目，各类型都做过，大到给某央企保险公司做，小到大湾区某高校做，正好高校有个AI项目，多一个又何妨?\n说句实话，我司的项目还是比较垃圾，学不到啥东西，做的几乎是CURD和工具类边角料，特别核心的也没接触，所有又学了点鱼皮的项目开始补充自己简历\n3. 代码部分(30min) # 手撕定长缓存，符合LRU，且确保是线程安全的，我就不展示代码，讲讲思路（不对的地方我可以改）（要求用伪代码，怎么写都行，最好按照你擅长的语言来写）\n首先，先定义一个带有时间戳的value类 其次，定义这个缓存（我用Map模拟的），这两个成员变量 一个Map\u0026lt;String, Value\u0026gt;缓存 还有个限制容量 最后开始完善写法，有两点注意事项 记得在读取的时候要更新时间，可以把更新时间这部分开另一个线程异步上锁 然后在写的时候记得上锁，这部分才是体现LRU算法的部分 4. 项目外问题(3min) # Spring的拦截器和过滤器有啥区别（这个一时没答上来） Spring注入Bean的一些方法（举例说明的） QPS和TPS定义（瞎j8答） 瞎聊 5. 你还有什么问题(2min) # 当时和面试官吐槽了一个问题，我以为达摩院的AI和通义家的AI是一套体系，我还说，你们的SDK封装挺难用的（叠个甲，我可不是这么说的，我只是表述这个意思），结果得到的就是它们是两家体系，555\n","date":"2024-11-28","externalUrl":null,"permalink":"/java/interview/epro-od-damo/","section":"Javas","summary":"","title":"易宝软件-外派达摩院AIGC项目组-面试（只有一次/回忆版本）","type":"java"},{"content":" 1. 初始化前情提要 # 此处以：2021.0.5.0 版本为例，Spring Boot 要求：2.6.13 版本\n其余对应组件版本如下\nSentinel Version Nacos Version RocketMQ Version Dubbo Version Seata Version 2021.0.6.0 1.8.6 2.2.0 4.9.4 ~ 1.6.1 2. 项目学习 # 参考：最佳实践示例-阿里云Spring Cloud Alibaba官网\n2.1 微服务的请求流程 # Nacos：集中存管项目中所有服务的信息，便于服务之间找到彼此；同时，还支持集中存储整个项目中的配置。\n2.2 微服务划分（以我的个人项目为例） # 依赖服务 注册中心：Nacos 微服务网关：Gateway，聚合所有接口，统一接受处理前端的请求 公共能力(bbg-backend-common)：异常处理、请求响应封装、AI能力 模型模块(bbg-backend-model)：实体类 公共接口模块(bbg-backend-service-client)：只存放接口，不存放实现 业务模块（详情请参考鱼答答项目） 用户模块(bbg-backend-user-service port:8102) 应用模块(bbg-backend-app-service port:8103) 题目模块(bbg-backend-question-service :8104) 评分模块(bbg-backend-scoring-service :8105) 用户回答模块(bbg-backend-answer-service :8106) 文件模块(bbg-backend-file-service :8107) 2.3 路由划分（以我的个人项目为例，inner代表内部调用，网关层面做限制） # 用户模块(bbg-backend-user-service port:8102): /api/user /api/user/inner 应用模块(含统计，bbg-backend-app-service port:8103): /api/app /api/app/inner 题目模块(bbg-backend-question-service :8104): /api/question /api/question/inner 评分模块(bbg-backend-scoring-service :8105): /api/scoringResult /api/scoringResult/inner 用户答案模块(bbg-backend-answer-service :8106): /api/userAnswer /api/userAnswer/inner 文件模块(bbg-backend-file-service :8107): /api/scoring /api/scoring/inner 2.4 Nacos 服务中心注册 # 官网：Nacos 配置中心简介, Nacos 是什么 | Nacos 官网\n请注意：案例版本中的Nacos对应的是2.2.0，故需要在这里下载Nacos\n安装完毕后，可以配置在环境变量里，以便随时启动Nacos\n2.5 工程新建 # 由于Spring Cloud 依赖众多，参差不齐，不建议随意找配置或手撸\n一定一定要自己积累工程文档，建议脚手架创建项目：Cloud Native App Initializer\n也可以像我一样来配置\n然后按照步骤操作，之后需要在maven中加载一个依赖，否则无法使用\n\u0026lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-dependencies --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2021.0.5\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 然后使用新建模块和Spring Boot初始化脚手架创建各个模块\n接下来绑定子父依赖，确保效果如下：\n以本项目为例，类似这个样子，每个子模块都要有\n\u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.jehol-ppx\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;bbg\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; 项目的pom.xml也要有这个东西\n\u0026lt;modules\u0026gt; \u0026lt;!-- 公共能力部分 --\u0026gt; \u0026lt;module\u0026gt;bbg-backend-common\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;bbg-backend-model\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;bbg-backend-service-client\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;bbg-backend-gateway\u0026lt;/module\u0026gt; \u0026lt;!-- 业务能力部分 --\u0026gt; \u0026lt;module\u0026gt;bbg-backend-user-service\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;bbg-backend-file-service\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;bbg-backend-answer-service\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;bbg-backend-app-service\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;bbg-backend-question-service\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;bbg-backend-scoring-service\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; 这才算大功告成\n子父依赖优势：父模块定义modules，子模块引入parent语法，可以通过继承父模块配置，统一项目的定义和版本号。\n2.6 同步代码\u0026amp;依赖 # 踩个坑：在引入完service-client包的时候，记得把application.propties删除掉，否则一直就是8080\n2.7 服务内部调用 # 现在的问题是，各个模块服务之间相互依赖，但代码已经被分到不同模块中了，无法找到对应的bean，我们需要引入Open Feign来实现跨服务远程调用\n首先，开始梳理项目\n用户模块(bbg-backend-user-service port:8102) 无 应用模块(bbg-backend-app-service port:8103) userService.getById(userId); userService.getUserVO(user); userService.listByIds(userIdSet) \u0026hellip; 题目模块(bbg-backend-question-service :8104) appService.getById(appId); userService.getById(userId); userService.getUserVO(user); userService.listByIds(userIdSet) \u0026hellip; 评分模块(bbg-backend-scoring-service :8105) appService.getById(appId); userService.getById(userId); userService.getUserVO(user); userService.listByIds(userIdSet) \u0026hellip; 用户回答模块(bbg-backend-answer-service :8106) appService.getById(appId); userService.getById(userId); userService.getUserVO(user); userService.listByIds(userIdSet) \u0026hellip; 文件模块(bbg-backend-file-service :8107) userService 接着，确定提供哪些接口\n用户模块(bbg-backend-user-service port:8102) userService.getById(userId); userService.getUserVO(user); userService.listByIds(userIdSet) isAdmin getLoginUser 应用模块(bbg-backend-app-service port:8103) appService.getById(appId); 最后，实现client接口\n开启 openfeign 的支持，把我们的接口暴露出去（服务注册到注册中心上），作为 API 给其他服务调用（其他服务从注册中心寻找) 需要修改每个服务提供者的context-path全局请求路径 服务提供者：理解为接口的实现类，实际提供服务的模块(服务注册到注册中心上) 服务消费者：理解为接口的调用方，需要去找到服务提供者，然后调用。\n注意事项：\n要给接口的每个方法打上请求注解，注意区分Get、Post 要给请求参数打上注解，比如 RequestParam、RequestBody FeignClient定义的请求路径一定要和服务提供方实际的请求路径保持一致 对于用户服务，有一些不利于远程调用参数传递、或者实现起来非常简单（工具类），可以直接用默认方法，无需远程调用，以节约性能 样例代码\npackage com.jeholppx.bbgbackendserviceclient.service; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import com.baomidou.mybatisplus.extension.service.IService; import com.jeholppx.bbgbackendcommon.common.ErrorCode; import com.jeholppx.bbgbackendcommon.constant.UserConstant; import com.jeholppx.bbgbackendcommon.exception.BusinessException; import com.jeholppx.bbgbackendcommon.utils.JWTUtils; import com.jeholppx.bbgbackendmodel.model.dto.user.UserQueryRequest; import com.jeholppx.bbgbackendmodel.model.entity.User; import com.jeholppx.bbgbackendmodel.model.enums.UserRoleEnum; import com.jeholppx.bbgbackendmodel.model.vo.LoginUserVO; import com.jeholppx.bbgbackendmodel.model.vo.UserVO; import org.apache.commons.lang3.StringUtils; import org.springframework.beans.BeanUtils; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; import javax.servlet.http.HttpServletRequest; import java.util.Collection; import java.util.List; import static com.jeholppx.bbgbackendcommon.constant.UserConstant.TOKEN; /** * 用户服务 * * @author \u0026lt;a href=\u0026#34;https://www.jehol-ppx.com\u0026#34;\u0026gt;热河fen青\u0026lt;/a\u0026gt; * @date 2024/10/14 19:00 */ @FeignClient(name = \u0026#34;bbg-backend-user-service\u0026#34;, path = \u0026#34;/api/user/inner\u0026#34;) public interface UserFeignClient { /** * 获取当前登录用户 * * @param request * @return */ default User getLoginUser(HttpServletRequest request) { // 先判断是否已登录 String token = (String) request.getSession().getAttribute(TOKEN); if (StringUtils.isBlank(token)) { throw new BusinessException(ErrorCode.NOT_LOGIN_ERROR); } // 通过token解析用户信息 return (User) JWTUtils.decode(token, User.class); } /** * 是否为管理员 * * @param user * @return */ default boolean isAdmin(User user) { return user != null \u0026amp;\u0026amp; UserRoleEnum.ADMIN.getValue().equals(user.getUserRole()); } /** * 获取脱敏的用户信息 * * @param user * @return */ default UserVO getUserVO(User user) { if (user == null) { return null; } UserVO userVO = new UserVO(); BeanUtils.copyProperties(user, userVO); return userVO; } /** * 获取用户列表 * @param id * @return */ @GetMapping(\u0026#34;/get/id\u0026#34;) User getById(@RequestParam(\u0026#34;userId\u0026#34;) Long id); /** * 获取用户列表 * @param ids * @return */ @GetMapping(\u0026#34;/get/ids\u0026#34;) List\u0026lt;User\u0026gt; listByIds(@RequestParam(\u0026#34;ids\u0026#34;) Collection\u0026lt;Long\u0026gt; ids); } ","date":"2024-10-26","externalUrl":null,"permalink":"/java/spring-cloud/init-spring-cloud/","section":"Javas","summary":"","title":"初始化一个Spring Cloud","type":"java"},{"content":" 1. 什么是微服务 # 1.1 定义 # 微服务是一种软件架构风格，它将一个大型的单体应用程序拆分成多个小的、独立的服务。每个服务都可以独立开发、部署和扩展，并且通常通过轻量级的通信机制（如HTTP或消息队列）进行交互。以下是微服务的一些关键特性：\n独立部署 ：每个微服务可以独立部署，不需要重新部署整个应用程序。 技术多样性 ：不同的微服务可以使用不同的技术栈，根据需要选择最合适的工具和语言。 松耦合 ：微服务之间通过明确的接口进行通信，减少了服务之间的依赖性。 专注单一职责 ：每个微服务专注于完成特定的业务功能，遵循单一职责原则。 弹性和可扩展性 ：可以根据需求独立扩展某个微服务，提高系统的弹性和可扩展性。 微服务架构的优点包括提高开发效率、增强系统的灵活性和可维护性，但也带来了分布式系统的复杂性，如服务发现、负载均衡、分布式事务和监控等问题。\n最好的形容： 一个人的公司，一旦生病，公司随时倒闭 =\u0026gt; 单体服务 多个人的公司，一人生命，公司继续运转不影响 =\u0026gt; 微服务\n1.2 使用场景 # 微服务架构适用于以下场景：\n复杂应用程序 ：当应用程序复杂且包含多个模块时，微服务可以将其拆分为更小的服务，便于管理和开发。 快速迭代 ：需要频繁发布新功能或更新的应用程序，微服务允许独立部署，减少发布周期。 团队规模大 ：大型团队可以根据功能模块划分为多个小团队，每个团队负责一个或多个微服务，减少团队间的依赖。 多样化技术栈 ：不同的服务可以使用不同的技术栈，选择最适合的工具和语言来实现特定功能。 高可扩展性 ：需要高可扩展性的应用程序，可以根据需求独立扩展某个微服务，提高系统的弹性。 高可用性要求 ：通过隔离故障，微服务架构可以提高系统的整体可用性，某个服务的故障不会影响整个系统。 这些场景下，微服务架构能够提供更高的灵活性、可维护性和可扩展性。\n2. 什么是 Spring Cloud # 信息来源：Spring Cloud\nSpring Cloud provides tools for developers to quickly build some of the common patterns in distributed systems (e.g. configuration management, service discovery, circuit breakers, intelligent routing, micro-proxy, control bus, short lived microservices and contract testing). Coordination of distributed systems leads to boiler plate patterns, and using Spring Cloud developers can quickly stand up services and applications that implement those patterns. They will work well in any distributed environment, including the developer’s own laptop, bare metal data centres, and managed platforms such as Cloud Foundry. 翻译后就是：Spring Cloud 为开发人员提供了工具，可以快速构建分布式系统中的一些常见模式（例如配置管理、服务发现、断路器、智能路由、微代理、控制总线、短生命周期微服务和契约测试）。分布式系统的协调会导致样板模式，使用 Spring Cloud，开发人员可以快速启动实现这些模式的服务和应用程序。它们在任何分布式环境中都能很好地工作，包括开发人员自己的笔记本电脑、裸机数据中心和托管平台（如 Cloud Foundry）。\n这段话主要描述了Spring Cloud为开发者提供了一套工具，这些工具可以帮助他们快速构建分布式系统中的一些常见模式。以下是对这段话的详细解释：\nSpring Cloud: 是一个基于Spring Boot的框架，它为微服务架构提供了一系列的解决方案。 tools for developers: Spring Cloud提供的工具，旨在帮助开发者。 quickly build some of the common patterns in distributed systems: 快速构建分布式系统中的常见模式。这些模式是分布式系统中普遍需要解决的问题，Spring Cloud通过提供工具来简化这些问题的解决过程。 e.g.: 举例说明，后面列举了一些分布式系统中的常见模式。 configuration management: 配置管理，指的是集中管理应用和服务的配置信息。 service discovery: 服务发现，允许服务在不知道彼此网络地址的情况下相互发现和通信。 circuit breakers: 断路器模式，防止系统过载的一种机制，当某个服务失败时，断路器可以防止进一步的请求发送到该服务。 intelligent routing: 智能路由，根据当前的系统状态和请求特性，智能地将请求路由到最合适的服务实例。 micro-proxy: 微代理，为微服务提供代理功能，可以进行请求转发、负载均衡等。 control bus: 控制总线，允许开发者在分布式系统中广播消息，用于配置更新、服务协调等。 short lived microservices: 短暂生命周期的微服务，指的是那些生命周期短、需要快速启动和停止的服务。 contract testing: 契约测试，确保服务之间的接口符合预期的约定。 Coordination of distributed systems: 分布式系统的协调，指的是在多个服务和组件之间进行通信和同步。 boiler plate patterns: 模板模式，指的是在构建分布式系统时需要重复使用的代码或模式。 stand up services and applications: 快速搭建服务和应用程序。 work well in any distributed environment: 在任何分布式环境中都能良好工作，包括开发者的个人笔记本电脑、裸机数据中心和像Cloud Foundry这样的托管平台。 总的来说，这段话强调了Spring Cloud如何通过提供一套工具来简化分布式系统开发中的常见问题，使得开发者能够快速构建、部署和运行分布式应用和服务。\n3. Spring Cloud Alibaba 介绍 # 3.0 建议学习官网 # 建议学习官网：Spring Cloud Alibaba官网_基于Springboot的微服务教程-阿里云，尤其要关注版本发布声明，这里有针对不同版本的适配的声明，如 SpringBoot 版本为 2.6.x ，需要使用2021版的相关组件\n一旦发生错误，后果不堪设想\n3.1 什么是Spring Cloud Alibaba # 本章主要来源：Spring Cloud Alibaba 是什么-阿里云Spring Cloud Alibaba官网\nSpring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里分布式应用解决方案，通过阿里中间件来迅速搭建分布式应用系统。此外，Spring Cloud Alibaba 企业版，包括无侵入服务治理(全链路灰度，无损上下线，离群实例摘除等)，企业级 Nacos 注册配置中心和企业级云原生网关等众多产品。\n但对于个人学习来讲，非企业版本即可足够使用\n本质：是在 Spring Cloud 的基础上，进行了增强，补充了一些额外的能力，根据阿里多年的业务沉淀做了一些定制化的开发\n这张图展示了Spring Cloud Alibaba与Spring Cloud的关系，并且详细列出了Spring Cloud Alibaba中的一些核心组件。以下是关于Spring Cloud标准实现和开源产品的详细介绍：\nSpring Cloud 标准实现\nRPC 调用：远程过程调用（Remote Procedure Call, RPC）是一种通信协议，允许在不同计算机上的程序相互调用对方的功能或服务。 服务注册\u0026amp;发现：服务注册与发现是微服务架构中的重要组成部分，用于动态地管理和查找可用的服务实例。 负载均衡：负载均衡是指将网络流量均匀分布到多个服务器上，以提高系统的响应速度和可靠性。 开源产品\nNacos：\nNacos是一个易于使用、功能强大的动态服务发现、配置管理和服务治理平台。 它支持服务注册与发现、分布式配置管理以及服务治理等功能。 Dubbo：\nDubbo是一款高性能、轻量级的开源Java RPC框架，它提供了面向接口的远程方法调用方案。 Dubbo的主要特点是性能高、易用性好、可扩展性强。 RocketMQ：\nRocketMQ是由阿里巴巴开发的一款开源消息中间件，具有高性能、低延迟的特点。 它支持发布/订阅模式的消息传递，适用于大规模分布式系统中的异步通信场景。 Seata：\nSeata是一个开源的分布式事务解决方案，旨在提供高性能和简单易用的分布式事务支持。 它通过全局事务协调器来保证分布式环境下的数据一致性。 Sentinel：\nSentinel是一个开源的流量控制库，主要用于保护后端服务免受大流量冲击。 它可以实时监控应用的入口流量，并根据预设规则进行限流、降级等操作。 Sidecar：\nSidecar模式通常用于微服务架构中，指的是为每个服务部署一个单独的进程，该进程负责处理服务之间的通信和其他辅助任务。 这种模式有助于解耦服务间的依赖关系，提高系统的灵活性和可维护性。 OSS (Object Storage Service)：\nOSS是阿里云提供的对象存储服务，用于存储和检索任意类型的文件。 它提供了高可用性和持久性的存储能力，适合于各种应用场景，如图片、视频、日志等非结构化数据的存储。 Schedulx：\nSchedulx是一个分布式调度平台，用于管理和执行定时任务。 它支持多种触发方式和丰富的任务类型，能够满足企业级应用的需求。 SMS (Short Message Service)：\nSMS模块通常指短信服务，用于发送和接收短信息。 在微服务架构中，它可以作为通知机制的一部分，用于用户认证、订单确认等场景。 这些组件共同构成了Spring Cloud Alibaba的核心功能，帮助开发者构建高效、可靠的微服务应用程序。\n","date":"2024-10-26","externalUrl":null,"permalink":"/java/spring-cloud/what-is-spring-cloud/","section":"Javas","summary":"","title":"微服务简介","type":"java"},{"content":" 0.课前作业 # 编写一个测试程序 # 要求如下\n源码文件以 _test结尾：xxx_test.go 测试方法名以 Test开头 func TestXXX(t *testing.T) { // ... here is your code } 样例代码\npackage try_test import \u0026#34;testing\u0026#34; func TestFirstTry(t *testing.T) { t.Log(\u0026#34;My first try!\u0026#34;) } Go语言赋值(变量定义)特点 # 与其它主要编程语言差异\n赋值可以自动进行类型推断 在一个赋值语句中可以对多个变量进行同时赋值 package fib import ( \u0026#34;fmt\u0026#34; \u0026#34;testing\u0026#34; ) func TestFibTest(t *testing.T) { // 第一种赋值方法 //var a int = 1 //var b int = 1 // 第二种 //var ( // a int = 1 // b = 1 //) // 第三种（推荐） //a := 1 //b := 1 // 假如函数返回值有多个，可以使用 a, b := 1, 1 t.Log(a) for i := 0; i \u0026lt; 5; i++ { t.Log(b) tmp := a a = b b = tmp + a } fmt.Println() } 测试结果\nGOROOT=/usr/local/go #gosetup GOPATH=/Users/jeholppx/go #gosetup /usr/local/go/bin/go test -c -o /Users/jeholppx/Library/Caches/JetBrains/GoLand2023.1/tmp/GoLand/___awesomeProject_src_ch2_fib__TestFibTest.test awesomeProject/src/ch2/fib #gosetup /usr/local/go/bin/go tool test2json -t /Users/jeholppx/Library/Caches/JetBrains/GoLand2023.1/tmp/GoLand/___awesomeProject_src_ch2_fib__TestFibTest.test -test.v -test.paniconexit0 -test.run ^\\QTestFibTest\\E$ === RUN TestFibTest fib_test.go:18: 1 fib_test.go:20: 1 fib_test.go:20: 2 fib_test.go:20: 3 fib_test.go:20: 5 fib_test.go:20: 8 --- PASS: TestFibTest (0.00s) PASS 样例2\n// 包名、引入均省略 func TestExchange(t *testing.T) { a := 1 b := 2 // 常规写法 //tmp := a //a = b //b = tmp // 连续赋值写法 a, b = b, a t.Log(\u0026#34;a =\u0026#34;, a, \u0026#34;b =\u0026#34;, b) } 输出结果\n/usr/local/go/bin/go tool test2json -t /Users/jeholppx/Library/Caches/JetBrains/GoLand2023.1/tmp/GoLand/___awesomeProject_src_ch2_fib__TestExchange.test -test.v -test.paniconexit0 -test.run ^\\QTestExchange\\E$ === RUN TestExchange fib_test.go:36: a = 2 b = 1 --- PASS: TestExchange (0.00s) PASS 常量的定义 # 快速设置连续的const值 # 常规连续值\npackage constant_test import \u0026#34;testing\u0026#34; // go 语言推荐的连续变量写法 const ( Monday = iota + 1 // 1 Tuesday // 2 Wednesday // 3 ) // 也可以像其他语言那样去写 //const ( // Monday = 1 // 1 // Tuesday = 2 // 2 // Wednesday = 3 // 3 //) func TestConstantTry(t *testing.T) { t.Log(Monday, Tuesday) } 测试结果\n=== RUN TestConstantTry constant_test.go:12: 1 2 --- PASS: TestConstantTry (0.00s) PASS 定义一个连续位移，且参与逻辑运算的const值 # // 声明包、导包略 // 连续位移写法 const ( Readable = 1 \u0026lt;\u0026lt; iota // 001 Writeable // 010 Executable // 100 ) func TestConstantTry1(t *testing.T) { a := 7 // 111 t.Log(a\u0026amp;Readable, a\u0026amp;Writeable, a\u0026amp;Executable) // 001 010 100 t.Log(\u0026#34;isReadable:\u0026#34;, a\u0026amp;Readable == Readable) t.Log(\u0026#34;isWriteable:\u0026#34;, a\u0026amp;Writeable == Writeable) t.Log(\u0026#34;isExecutable:\u0026#34;, a\u0026amp;Executable == Executable) } 运行结果\n=== RUN TestConstantTry1 constant_test.go:21: 1 2 4 constant_test.go:22: isReadable: true constant_test.go:23: isWriteable: true constant_test.go:24: isExecutable: true --- PASS: TestConstantTry1 (0.00s) PASS 基本数据类型 # 数据类型分类 # 常见的基本数据类型，可分为以下几类\n布尔型：bool 字符型：string 整型：int int8 int16 int32 int64 无符号整型：uint uint8 uint16 uint32 uint64 uintptr 字节型：byte // alias for uint8 unicode编码值：rune // alias for int32 浮点型：float32 float64 复数型：complex64 complex128 差异 # 与其它主要编程语言的差异\n❌ Golang 不允许隐式类型转换 ❌ 别名与原有类型之间也不能进行隐式转换 错误案例1：隐式变量转换 int to int64\npackage type_test import \u0026#34;testing\u0026#34; func TestImplicit(t *testing.T) { var a int = 1 var b int64 b = a t.Log(a, b) } 运行结果\n# awesomeProject/src/ch3/type_test_test [awesomeProject/src/ch3/type_test.test] ./type_test.go:8:6: cannot use a (variable of type int) as type int64 in assignment 错误案例2：int32 to int64\npackage type_test import \u0026#34;testing\u0026#34; func TestImplicit(t *testing.T) { var a int32 = 1 // 差异点 var b int64 b = a // 修正方案：b = int64(a) t.Log(a, b) } 运行结果\n# awesomeProject/src/ch3/type_test_test [awesomeProject/src/ch3/type_test.test] ./type_test.go:8:6: cannot use a (variable of type int32) as type int64 in assignment 错误用例2修正后\n// ignore package claim and import packages func TestImplicit(t *testing.T) { var a int32 = 1 var b int64 b = int64(a) t.Log(\u0026#34;a =\u0026#34;, a, \u0026#34;b =\u0026#34;, b) } 改进后的错误用例2\n=== RUN TestImplicit type_test.go:11: a = 1 b = 1 --- PASS: TestImplicit (0.00s) PASS 错误用例3：别名与原名类型间的转换\ntype MyInteger int64 func TestImplicit(t *testing.T) { var a int32 = 1 var b int64 b = int64(a) var c MyInteger c = b t.Log(\u0026#34;a =\u0026#34;, a, \u0026#34;b =\u0026#34;, b, \u0026#34;c = \u0026#34;, c) } 运行结果\n# awesomeProject/src/ch3/type_test_test [awesomeProject/src/ch3/type_test.test] ./type_test.go:12:6: cannot use b (variable of type int64) as type MyInteger in assignment 改进方法\nfunc TestImplicit(t *testing.T) { var a int32 = 1 var b int64 b = int64(a) var c MyInteger c = MyInteger(b) // 正解 t.Log(\u0026#34;a =\u0026#34;, a, \u0026#34;b =\u0026#34;, b, \u0026#34;c = \u0026#34;, c) } 运行结果\n=== RUN TestImplicit type_test.go:13: a = 1 b = 1 c = 1 --- PASS: TestImplicit (0.00s) PASS 预定义值 # 以下预定义值很常见，仅举几例\nmath.MaxInt64 math.MaxFloat64 math.MaxUint32 指针类型 # 与C/C++不同的是\n不支持指针运算 string是值类型，其默认初始化值为空字符串，而不是 nil（go语言中, null其实是 nil） 样例1（正例）\nfunc TestPoint(t *testing.T) { a := 1 aPtr := \u0026amp;a t.Log(\u0026#34;a =\u0026#34;, a, \u0026#34;\\nA\u0026#39;s RAM address is\u0026#34;, aPtr) t.Logf(\u0026#34;a type is %T, aPtr type is %T\u0026#34;, a, aPtr) } 运行结果\n=== RUN TestPoint type_test.go:19: a = 1 A\u0026#39;s RAM address is 0x1400010a1d8 type_test.go:20: a type is int, aPtr type is *int --- PASS: TestPoint (0.00s) PASS 到这里会以为和C/C++没什么两样，但是，这样做可以吗？\nfunc TestPoint(t *testing.T) { a := 1 aPtr := \u0026amp;a aPtr = aPtr + 1 // 请判断正误 t.Log(\u0026#34;a =\u0026#34;, a, \u0026#34;\\nA\u0026#39;s RAM address is\u0026#34;, aPtr) t.Logf(\u0026#34;a type is %T, aPtr type is %T\u0026#34;, a, aPtr) } 在判断做法后，看下结果和你预想的是否一样\n# awesomeProject/src/ch3/type_test_test [awesomeProject/src/ch3/type_test.test] ./type_test.go:19:16: cannot convert 1 (untyped int constant) to *int 用例2 字符串\nfunc TestString(t *testing.T) { var s string t.Log(\u0026#34;*\u0026#34; + s + \u0026#34;*\u0026#34;) t.Log(\u0026#34;Is var \\\u0026#34;s\\\u0026#34; an empty-string ?\u0026#34;, s == \u0026#34;\u0026#34;) t.Log(\u0026#34;s longs:\u0026#34;, len(s)) } 运行结果\n=== RUN TestString type_test.go:26: ** type_test.go:27: Is var \u0026#34;s\u0026#34; an empty-string ? true type_test.go:28: s longs: 0 --- PASS: TestString (0.00s) PASS 判断字符串为空，这样可以吗？\nfunc TestString(t *testing.T) { var s string t.Log(\u0026#34;*\u0026#34; + s + \u0026#34;*\u0026#34;) t.Log(\u0026#34;s longs:\u0026#34;, len(s)) // 这样判断可以吗？ if s == nil { t.Log(\u0026#34;s is empty\u0026#34;) } else { t.Log(\u0026#34;s is not empty\u0026#34;) } } 揭晓答案\n# awesomeProject/src/ch3/type_test_test [awesomeProject/src/ch3/type_test.test] ./type_test.go:29:10: invalid operation: s == nil (mismatched types string and untyped nil) 显然这样做是错的，因为string的默认值为空字符串，因此不要这样做\n正解如下：\nfunc TestString(t *testing.T) { var s string t.Log(\u0026#34;*\u0026#34; + s + \u0026#34;*\u0026#34;) t.Log(\u0026#34;s longs:\u0026#34;, len(s)) // 改进如下 if s == \u0026#34;\u0026#34; { t.Log(\u0026#34;s is empty\u0026#34;) } else { t.Log(\u0026#34;s is not empty\u0026#34;) } } 运行结果\n=== RUN TestString type_test.go:30: s is empty --- PASS: TestString (0.00s) PASS 小结和注意事项 # ❌：不允许隐式类型转换，尤其同一种类型的不同别名 ❌：指针类型不可以参与任何运算 ✅：判断字符串是某个值可以直接使用 ==，不为空使用 != ✅：判断字符串为空可以用 str == \u0026quot;\u0026quot;来表示 ❌：不可以用 str == nil判空 ","date":"2024-10-11","externalUrl":null,"permalink":"/golang/golang-basic/chapter-3/","section":"Golangs","summary":"","title":"第三章-变量、常量类型及使用技巧","type":"golang"},{"content":" 1. 环境安装 # 安装Go语言环境在Windows，Linux和Mac上的步骤略有不同。以下是各个操作系统的安装过程：\n要配置Go语言环境的特定版本（例如1.19），你需要执行以下步骤：\n首先，确保已经安装了Go语言环境。你可以通过在终端中运行以下命令来验证安装： go version 如果能够显示已安装的Go版本，则说明安装成功。\n访问Go官方网站（https://golang.org/dl/），并下载所需版本的Go安装程序或安装包。选择与你的操作系统和架构相对应的版本。 安装所下载的Go版本。根据你的操作系统，有以下几种安装方法： Windows: 双击下载的安装程序并按照提示完成安装过程。默认情况下，Go将安装在 C:\\Go目录下。 Linux: 解压下载的安装包到你选择的目录。例如，可以将其解压到 /usr/local目录下： tar -C /usr/local -xzf go1.19.linux-amd64.tar.gz 注意将 go1.19.linux-amd64.tar.gz替换成你下载的安装包的实际文件名。\nMac: 双击下载的安装包并按照提示完成安装过程。默认情况下，Go将安装在 /usr/local/go目录下。 现在，你需要使用环境变量来设置Go的版本和路径。打开你的终端，并执行以下命令： Windows: 在 系统属性 -\u0026gt; 高级 -\u0026gt; 环境变量中，添加一个名为 GOROOT的变量，并将其值设置为Go的安装路径（例如 C:\\Go）。然后，在 Path变量中添加 %GOROOT%\\bin。 Linux和Mac: 使用文本编辑器打开你的 ~/.profile文件或者 ~/.bashrc文件，并添加以下内容： export GOROOT=/usr/local/go export PATH=$PATH:$GOROOT/bin 或者，如果你使用的是Zsh终端，请修改命令为：\n保存并关闭文件，然后在终端中执行以下命令使配置生效： Windows: 关闭并重新打开终端。 Linux和Mac: 在终端中执行以下命令： source ~/.profile 或者\n最后，使用以下命令验证Go的版本和安装是否正确： go version 如果能够显示你安装的Go版本（例如go1.19），则说明配置成功。\n现在，你已经成功配置了Go语言环境的特定版本（1.19），可以开始使用它进行开发了。记得设置好Go的工作路径（GOPATH）和选择一个集成开发环境（IDE）或者文本编辑器进行编码，这里使用Goland。\n2. 编码 # 2.1 准备工作 # 新建一个项目，结构如下\n2.2 编码 # package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 完成以后，在控制台输入指令\ncd src/ch1/main/ go run hello_world.go 显示结果\nHello, World! 如果编译源码，需要另一个指令\ngo build hello_world.go 执行后，可以看到一个可执行程式\nmain \u0026gt; ll total 3784 -rwxr-xr-x@ 1 jeholppx staff 1.8M Jul 9 11:10 hello_world -rw-r--r--@ 1 jeholppx staff 74B Jul 9 11:05 hello_world.go 只要执行这个 hello_world就可以打印上面的结果\n2.3 基本程序结构 # package main // 包，表明代码所在的模块（包） import \u0026#34;fmt\u0026#34; // 引入代码的依赖 // 功能实现 func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 2.4 应用程序入口的标准 # 例程中helloworld是应用程序的入口，作为入口，有以下的基本要求\n必须是main包/模块，声明为 package main，目录名不一定为 main 必须是main方法 func main() 文件名不一定写 main.go，也可以是其他名字 2.4.1 实验 # 新建一个文件夹，拷贝源码，并执行 go run\n# 回到上一级目录 cd .. # 新建一个hello的文件夹 mkdir hello # 复制2.2的源码 cp ./main/hello_world.go ./hello/hello_world.go # 切换文件夹并执行源码 cd ./hello go run hello_world.go 运行结果如下\nHello, World! 如果修改源码\npackage main1 // before is main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 重新运行编译就会提示\npackage command-line-arguments is not a main package 2.5 main函数与其他编程语言的差异 # 2.5.1 返回值方面 # C(++)/Java中：有指定的返回值\nGo语言中\nmain()不支持任何返回值 通过 os.Exit来返回状态 加返回值实验如下\npackage main import \u0026#34;fmt\u0026#34; func main() int { fmt.Println(\u0026#34;Hello, World!\u0026#34;) return 0 } go run hello_world.go # command-line-arguments ./hello_world.go:5:6: func main must have no arguments and no return values 若要返回状态，操作方法如下\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) os.Exit(0) // 返回值 } 这样又可以正常运行了\n当然，返回值也可以定义为一个异常值，如-1\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) os.Exit(-1) // 异常返回 } 运行结果如下\nHello, World! exit status 255 # 异常状态 2.5.2 传参方面 # C++/Java 可以在main函数传参，args string[] 类型\nGo不可以这样做\nmain()本身就不支持传参 需要通过 os.Args()获取参数 程序实例如下\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { args := os.Args fmt.Println(\u0026#34;Hello, World!\u0026#34;) fmt.Println(args) os.Exit(0) } \u0026gt; go run hello_world.go Hello, World! [/var/folders/s5/lh51989j3qv9nrz2p9tdjc8h0000gn/T/go-build3482274569/b001/exe/hello_world] \u0026gt; go run hello_world.go chao Hello, World! [/var/folders/s5/lh51989j3qv9nrz2p9tdjc8h0000gn/T/go-build2433158551/b001/exe/hello_world chao] 第二个例子\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { if len(os.Args) \u0026gt; 1 { fmt.Println(\u0026#34;Hello, World!\u0026#34;, os.Args[1]) } } \u0026gt; go run hello_world.go ppx Hello, World! ppx ","date":"2024-10-11","externalUrl":null,"permalink":"/golang/golang-basic/chapter-2/","section":"Golangs","summary":"","title":"第二章-开始Golang学习","type":"golang"},{"content":"","date":"2024-10-11","externalUrl":null,"permalink":"/tags/go/","section":"Tags","summary":"","title":"Go","type":"tags"},{"content":"","date":"2024-10-11","externalUrl":null,"permalink":"/tags/golang/","section":"Tags","summary":"","title":"Golang","type":"tags"},{"content":"","date":"2024-10-11","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" 1. 前导篇 # 1.1 不同版本的特性 # 参考文章：Go语言各版本特性回顾（1.5-1.14）-腾讯云开发者社区-腾讯云\n1.2 核心特性 # 1.2.1 Go的特性 # 吸收和接纳其他语言的特性 在开发中，能够抓牢程序员的痛点，以简单直接且高效稳定的方式来解决问题 不仅编译迅速，还具有强大的垃圾收集机制和运行反射机制 快速的、静态类型的编译型语言，又有动态类型解释型语言的感觉 表达能力强：简洁清晰高效 思想：大道至简，小而蕴真 1.2.2 核心特性1-并发编程 # 在当今这个时代，并发编程的意义不言而喻，因此Golang具有以下并发编程特点\n简洁程度要胜过绝大多数语言，这是最大的亮点之一，他也是未来进入高并发高性能场景的重要筹码 不同于传统的多进程和多线程，golang的并发执行单元是一种称为goroutine的协程，语言级别关键字 go用于启动协程，并且在同一台机器上启动成千上百个协程；协程间一般由应用程序显示调度，上下文切换无需下到内核层，使得更加高效，通信靠独有的channel机制实现 1.2.3 内存回收(GC) # 内存自动回收，再也不需要开发人员管理内存。回收过程如下： 首先stop the world, 扫描所有对象判活，把可回收对象在一段bitmap区中标记下来 接着立即start the world，回复服务，同时启动一个专门的gorountine，回收内存到空闲list中以备复用 开发人员专注业务实现，降低心智负担 只需要new分配内存，无需物理释放(它由专门线程顶起来执行)； GC瓶颈在于每次都要扫描所有对象来判活，带收集对象越多，速度越慢；其性能会随版本更新而不断优化 1.2.4 内存分配 # 先分配一块大内存区域 大内存被分成各个大小等级的块，放入不同的空闲list中 对象分配空闲时从空闲list中取出大小合适的内存块 内存回收时，会把不用的内存重放会空闲list 空闲内存机制按照一定策略合并，以减少碎片 1.2.5 编译 # 目前Golang具有两种编译器\nGccgo，建立在GCC基础之上 另一种是针对x64和x86计算机的一套编译器(6g和8g) 依赖管理，在代码中的 import中加上github路径即可，库默认下载到pkg目录上 编译时默认会检查代码中所有尸体的使用情况，凡是没用到的package或变量，一定会编译不通过；这确保了go语言的严谨性 1.2.6 网络编程 # Go语言诞生在互联网时代，故天生就具有去中心化、分布式等特性，其中一个具体表现就是提供了丰富的网络编程接口\nsocket用 net.Dial(基于TCP/UDP，封装了传统的 connect``listen``accept等接口) http用 http.Get()或 http.Post() rpc用 client.Call('class_name.method_name', args, \u0026amp;reply) 重要能力：自带高性能HttpServer，通过几行代码就可以得到一个基于协程的高性能Web服务，更重要的是，维护成本极低，没有任何依赖 1.2.7 函数多返回值 # 这个是Go语言与其他传统语言在函数方面上的其中一个区别\n允许函数返回多个值，在某些场景下，可以有效简化编程 由于其官方推荐在函数返回的最后一个参数为error类（只要在逻辑中体现异常），这才有必要要求允许返回多个值 1.2.8 语言交互性 # 定义：本语言是否可以和其他语言交互，比如可以调用其他语言编译的库 Go可以与C程序交互，交互工具叫Cgo，它还可以允许开发者混合编写C语言代码，然后Cgo工具可以把混写的代码提取并生成对于C功能的调用包装代码，开发者可以完全忽略而这边界如何跨越的 1.2.9 异常处理 # 为防止代码量增加以及被滥用（不管多小的异常都要抛出），Go不支持 try ... catch 块，Go处理方式为 defer...recover...panic\ndefer：函数结束后执行，呈先进后出 panic：程序出现无法修复的错误时使用，但defer要执行完，如除以0 recover：会修复错误，不至于程序种植，如果不确定函数会不会出错，就用defer+recover 若异常严重，由Go语言内部自动抛出，用户无需抛出，如果使用 panic(str)就会退化到try-catch块那种模式 1.2.10 其他特性 # 类的推导，可以用var来定义变量（注意：虽然可以用var，但Go毕竟是强类型语言） interface，一个类型只要实现了某个interface的所有方法，即可实现该interface，无需显示继承；Go编程规范推荐每个接口类只提供1-2个方法，这样使每个接口类的目的非常清晰 defer：Go语言关键字，可通过它指定需要延迟执行的逻辑体（在函数体return前或出现panic执行），这种机制适合善后逻辑处理（如资源泄露） \u0026ldquo;包\u0026quot;的概念：和python相同，把相同功能代码放到一个目录，称之为包，包可以被其他包引用，每个程序只有一个main包供其执行 交叉编译：不受系统限制 ","date":"2024-10-11","externalUrl":null,"permalink":"/golang/golang-basic/chapter-1/","section":"Golangs","summary":"","title":"第一章-Golang简介","type":"golang"},{"content":"","date":"2024-10-11","externalUrl":null,"permalink":"/tags/%E5%9F%BA%E7%A1%80/","section":"Tags","summary":"","title":"基础","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]