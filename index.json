[{"content":"","date":"2024-10-26","externalUrl":null,"permalink":"/java/","section":"Javas","summary":"","title":"Javas","type":"java"},{"content":"","date":"2024-10-26","externalUrl":null,"permalink":"/","section":"热河fen青","summary":"","title":"热河fen青","type":"page"},{"content":"","date":"2024-10-11","externalUrl":null,"permalink":"/golang/","section":"Golangs","summary":"","title":"Golangs","type":"golang"},{"content":" 0.课前作业 # 编写一个测试程序 # 要求如下\n源码文件以 _test结尾：xxx_test.go 测试方法名以 Test开头 func TestXXX(t *testing.T) { // ... here is your code } 样例代码\npackage try_test import \u0026#34;testing\u0026#34; func TestFirstTry(t *testing.T) { t.Log(\u0026#34;My first try!\u0026#34;) } Go语言赋值(变量定义)特点 # 与其它主要编程语言差异\n赋值可以自动进行类型推断 在一个赋值语句中可以对多个变量进行同时赋值 package fib import ( \u0026#34;fmt\u0026#34; \u0026#34;testing\u0026#34; ) func TestFibTest(t *testing.T) { // 第一种赋值方法 //var a int = 1 //var b int = 1 // 第二种 //var ( // a int = 1 // b = 1 //) // 第三种（推荐） //a := 1 //b := 1 // 假如函数返回值有多个，可以使用 a, b := 1, 1 t.Log(a) for i := 0; i \u0026lt; 5; i++ { t.Log(b) tmp := a a = b b = tmp + a } fmt.Println() } 测试结果\nGOROOT=/usr/local/go #gosetup GOPATH=/Users/jeholppx/go #gosetup /usr/local/go/bin/go test -c -o /Users/jeholppx/Library/Caches/JetBrains/GoLand2023.1/tmp/GoLand/___awesomeProject_src_ch2_fib__TestFibTest.test awesomeProject/src/ch2/fib #gosetup /usr/local/go/bin/go tool test2json -t /Users/jeholppx/Library/Caches/JetBrains/GoLand2023.1/tmp/GoLand/___awesomeProject_src_ch2_fib__TestFibTest.test -test.v -test.paniconexit0 -test.run ^\\QTestFibTest\\E$ === RUN TestFibTest fib_test.go:18: 1 fib_test.go:20: 1 fib_test.go:20: 2 fib_test.go:20: 3 fib_test.go:20: 5 fib_test.go:20: 8 --- PASS: TestFibTest (0.00s) PASS 样例2\n// 包名、引入均省略 func TestExchange(t *testing.T) { a := 1 b := 2 // 常规写法 //tmp := a //a = b //b = tmp // 连续赋值写法 a, b = b, a t.Log(\u0026#34;a =\u0026#34;, a, \u0026#34;b =\u0026#34;, b) } 输出结果\n/usr/local/go/bin/go tool test2json -t /Users/jeholppx/Library/Caches/JetBrains/GoLand2023.1/tmp/GoLand/___awesomeProject_src_ch2_fib__TestExchange.test -test.v -test.paniconexit0 -test.run ^\\QTestExchange\\E$ === RUN TestExchange fib_test.go:36: a = 2 b = 1 --- PASS: TestExchange (0.00s) PASS 常量的定义 # 快速设置连续的const值 # 常规连续值\npackage constant_test import \u0026#34;testing\u0026#34; // go 语言推荐的连续变量写法 const ( Monday = iota + 1 // 1 Tuesday // 2 Wednesday // 3 ) // 也可以像其他语言那样去写 //const ( // Monday = 1 // 1 // Tuesday = 2 // 2 // Wednesday = 3 // 3 //) func TestConstantTry(t *testing.T) { t.Log(Monday, Tuesday) } 测试结果\n=== RUN TestConstantTry constant_test.go:12: 1 2 --- PASS: TestConstantTry (0.00s) PASS 定义一个连续位移，且参与逻辑运算的const值 # // 声明包、导包略 // 连续位移写法 const ( Readable = 1 \u0026lt;\u0026lt; iota // 001 Writeable // 010 Executable // 100 ) func TestConstantTry1(t *testing.T) { a := 7 // 111 t.Log(a\u0026amp;Readable, a\u0026amp;Writeable, a\u0026amp;Executable) // 001 010 100 t.Log(\u0026#34;isReadable:\u0026#34;, a\u0026amp;Readable == Readable) t.Log(\u0026#34;isWriteable:\u0026#34;, a\u0026amp;Writeable == Writeable) t.Log(\u0026#34;isExecutable:\u0026#34;, a\u0026amp;Executable == Executable) } 运行结果\n=== RUN TestConstantTry1 constant_test.go:21: 1 2 4 constant_test.go:22: isReadable: true constant_test.go:23: isWriteable: true constant_test.go:24: isExecutable: true --- PASS: TestConstantTry1 (0.00s) PASS 基本数据类型 # 数据类型分类 # 常见的基本数据类型，可分为以下几类\n布尔型：bool 字符型：string 整型：int int8 int16 int32 int64 无符号整型：uint uint8 uint16 uint32 uint64 uintptr 字节型：byte // alias for uint8 unicode编码值：rune // alias for int32 浮点型：float32 float64 复数型：complex64 complex128 差异 # 与其它主要编程语言的差异\n❌ Golang 不允许隐式类型转换 ❌ 别名与原有类型之间也不能进行隐式转换 错误案例1：隐式变量转换 int to int64\npackage type_test import \u0026#34;testing\u0026#34; func TestImplicit(t *testing.T) { var a int = 1 var b int64 b = a t.Log(a, b) } 运行结果\n# awesomeProject/src/ch3/type_test_test [awesomeProject/src/ch3/type_test.test] ./type_test.go:8:6: cannot use a (variable of type int) as type int64 in assignment 错误案例2：int32 to int64\npackage type_test import \u0026#34;testing\u0026#34; func TestImplicit(t *testing.T) { var a int32 = 1 // 差异点 var b int64 b = a // 修正方案：b = int64(a) t.Log(a, b) } 运行结果\n# awesomeProject/src/ch3/type_test_test [awesomeProject/src/ch3/type_test.test] ./type_test.go:8:6: cannot use a (variable of type int32) as type int64 in assignment 错误用例2修正后\n// ignore package claim and import packages func TestImplicit(t *testing.T) { var a int32 = 1 var b int64 b = int64(a) t.Log(\u0026#34;a =\u0026#34;, a, \u0026#34;b =\u0026#34;, b) } 改进后的错误用例2\n=== RUN TestImplicit type_test.go:11: a = 1 b = 1 --- PASS: TestImplicit (0.00s) PASS 错误用例3：别名与原名类型间的转换\ntype MyInteger int64 func TestImplicit(t *testing.T) { var a int32 = 1 var b int64 b = int64(a) var c MyInteger c = b t.Log(\u0026#34;a =\u0026#34;, a, \u0026#34;b =\u0026#34;, b, \u0026#34;c = \u0026#34;, c) } 运行结果\n# awesomeProject/src/ch3/type_test_test [awesomeProject/src/ch3/type_test.test] ./type_test.go:12:6: cannot use b (variable of type int64) as type MyInteger in assignment 改进方法\nfunc TestImplicit(t *testing.T) { var a int32 = 1 var b int64 b = int64(a) var c MyInteger c = MyInteger(b) // 正解 t.Log(\u0026#34;a =\u0026#34;, a, \u0026#34;b =\u0026#34;, b, \u0026#34;c = \u0026#34;, c) } 运行结果\n=== RUN TestImplicit type_test.go:13: a = 1 b = 1 c = 1 --- PASS: TestImplicit (0.00s) PASS 预定义值 # 以下预定义值很常见，仅举几例\nmath.MaxInt64 math.MaxFloat64 math.MaxUint32 指针类型 # 与C/C++不同的是\n不支持指针运算 string是值类型，其默认初始化值为空字符串，而不是 nil（go语言中, null其实是 nil） 样例1（正例）\nfunc TestPoint(t *testing.T) { a := 1 aPtr := \u0026amp;a t.Log(\u0026#34;a =\u0026#34;, a, \u0026#34;\\nA\u0026#39;s RAM address is\u0026#34;, aPtr) t.Logf(\u0026#34;a type is %T, aPtr type is %T\u0026#34;, a, aPtr) } 运行结果\n=== RUN TestPoint type_test.go:19: a = 1 A\u0026#39;s RAM address is 0x1400010a1d8 type_test.go:20: a type is int, aPtr type is *int --- PASS: TestPoint (0.00s) PASS 到这里会以为和C/C++没什么两样，但是，这样做可以吗？\nfunc TestPoint(t *testing.T) { a := 1 aPtr := \u0026amp;a aPtr = aPtr + 1 // 请判断正误 t.Log(\u0026#34;a =\u0026#34;, a, \u0026#34;\\nA\u0026#39;s RAM address is\u0026#34;, aPtr) t.Logf(\u0026#34;a type is %T, aPtr type is %T\u0026#34;, a, aPtr) } 在判断做法后，看下结果和你预想的是否一样\n# awesomeProject/src/ch3/type_test_test [awesomeProject/src/ch3/type_test.test] ./type_test.go:19:16: cannot convert 1 (untyped int constant) to *int 用例2 字符串\nfunc TestString(t *testing.T) { var s string t.Log(\u0026#34;*\u0026#34; + s + \u0026#34;*\u0026#34;) t.Log(\u0026#34;Is var \\\u0026#34;s\\\u0026#34; an empty-string ?\u0026#34;, s == \u0026#34;\u0026#34;) t.Log(\u0026#34;s longs:\u0026#34;, len(s)) } 运行结果\n=== RUN TestString type_test.go:26: ** type_test.go:27: Is var \u0026#34;s\u0026#34; an empty-string ? true type_test.go:28: s longs: 0 --- PASS: TestString (0.00s) PASS 判断字符串为空，这样可以吗？\nfunc TestString(t *testing.T) { var s string t.Log(\u0026#34;*\u0026#34; + s + \u0026#34;*\u0026#34;) t.Log(\u0026#34;s longs:\u0026#34;, len(s)) // 这样判断可以吗？ if s == nil { t.Log(\u0026#34;s is empty\u0026#34;) } else { t.Log(\u0026#34;s is not empty\u0026#34;) } } 揭晓答案\n# awesomeProject/src/ch3/type_test_test [awesomeProject/src/ch3/type_test.test] ./type_test.go:29:10: invalid operation: s == nil (mismatched types string and untyped nil) 显然这样做是错的，因为string的默认值为空字符串，因此不要这样做\n正解如下：\nfunc TestString(t *testing.T) { var s string t.Log(\u0026#34;*\u0026#34; + s + \u0026#34;*\u0026#34;) t.Log(\u0026#34;s longs:\u0026#34;, len(s)) // 改进如下 if s == \u0026#34;\u0026#34; { t.Log(\u0026#34;s is empty\u0026#34;) } else { t.Log(\u0026#34;s is not empty\u0026#34;) } } 运行结果\n=== RUN TestString type_test.go:30: s is empty --- PASS: TestString (0.00s) PASS 小结和注意事项 # ❌：不允许隐式类型转换，尤其同一种类型的不同别名 ❌：指针类型不可以参与任何运算 ✅：判断字符串是某个值可以直接使用 ==，不为空使用 != ✅：判断字符串为空可以用 str == \u0026quot;\u0026quot;来表示 ❌：不可以用 str == nil判空 ","date":"2024-10-11","externalUrl":null,"permalink":"/golang/golang-basic/chapter-3/","section":"Golangs","summary":"","title":"第三章-变量、常量类型及使用技巧","type":"golang"},{"content":" 1. 环境安装 # 安装Go语言环境在Windows，Linux和Mac上的步骤略有不同。以下是各个操作系统的安装过程：\n要配置Go语言环境的特定版本（例如1.19），你需要执行以下步骤：\n首先，确保已经安装了Go语言环境。你可以通过在终端中运行以下命令来验证安装： go version 如果能够显示已安装的Go版本，则说明安装成功。\n访问Go官方网站（https://golang.org/dl/），并下载所需版本的Go安装程序或安装包。选择与你的操作系统和架构相对应的版本。 安装所下载的Go版本。根据你的操作系统，有以下几种安装方法： Windows: 双击下载的安装程序并按照提示完成安装过程。默认情况下，Go将安装在 C:\\Go目录下。 Linux: 解压下载的安装包到你选择的目录。例如，可以将其解压到 /usr/local目录下： tar -C /usr/local -xzf go1.19.linux-amd64.tar.gz 注意将 go1.19.linux-amd64.tar.gz替换成你下载的安装包的实际文件名。\nMac: 双击下载的安装包并按照提示完成安装过程。默认情况下，Go将安装在 /usr/local/go目录下。 现在，你需要使用环境变量来设置Go的版本和路径。打开你的终端，并执行以下命令： Windows: 在 系统属性 -\u0026gt; 高级 -\u0026gt; 环境变量中，添加一个名为 GOROOT的变量，并将其值设置为Go的安装路径（例如 C:\\Go）。然后，在 Path变量中添加 %GOROOT%\\bin。 Linux和Mac: 使用文本编辑器打开你的 ~/.profile文件或者 ~/.bashrc文件，并添加以下内容： export GOROOT=/usr/local/go export PATH=$PATH:$GOROOT/bin 或者，如果你使用的是Zsh终端，请修改命令为：\n保存并关闭文件，然后在终端中执行以下命令使配置生效： Windows: 关闭并重新打开终端。 Linux和Mac: 在终端中执行以下命令： source ~/.profile 或者\n最后，使用以下命令验证Go的版本和安装是否正确： go version 如果能够显示你安装的Go版本（例如go1.19），则说明配置成功。\n现在，你已经成功配置了Go语言环境的特定版本（1.19），可以开始使用它进行开发了。记得设置好Go的工作路径（GOPATH）和选择一个集成开发环境（IDE）或者文本编辑器进行编码，这里使用Goland。\n2. 编码 # 2.1 准备工作 # 新建一个项目，结构如下\n2.2 编码 # package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 完成以后，在控制台输入指令\ncd src/ch1/main/ go run hello_world.go 显示结果\nHello, World! 如果编译源码，需要另一个指令\ngo build hello_world.go 执行后，可以看到一个可执行程式\nmain \u0026gt; ll total 3784 -rwxr-xr-x@ 1 jeholppx staff 1.8M Jul 9 11:10 hello_world -rw-r--r--@ 1 jeholppx staff 74B Jul 9 11:05 hello_world.go 只要执行这个 hello_world就可以打印上面的结果\n2.3 基本程序结构 # package main // 包，表明代码所在的模块（包） import \u0026#34;fmt\u0026#34; // 引入代码的依赖 // 功能实现 func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 2.4 应用程序入口的标准 # 例程中helloworld是应用程序的入口，作为入口，有以下的基本要求\n必须是main包/模块，声明为 package main，目录名不一定为 main 必须是main方法 func main() 文件名不一定写 main.go，也可以是其他名字 2.4.1 实验 # 新建一个文件夹，拷贝源码，并执行 go run\n# 回到上一级目录 cd .. # 新建一个hello的文件夹 mkdir hello # 复制2.2的源码 cp ./main/hello_world.go ./hello/hello_world.go # 切换文件夹并执行源码 cd ./hello go run hello_world.go 运行结果如下\nHello, World! 如果修改源码\npackage main1 // before is main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 重新运行编译就会提示\npackage command-line-arguments is not a main package 2.5 main函数与其他编程语言的差异 # 2.5.1 返回值方面 # C(++)/Java中：有指定的返回值\nGo语言中\nmain()不支持任何返回值 通过 os.Exit来返回状态 加返回值实验如下\npackage main import \u0026#34;fmt\u0026#34; func main() int { fmt.Println(\u0026#34;Hello, World!\u0026#34;) return 0 } go run hello_world.go # command-line-arguments ./hello_world.go:5:6: func main must have no arguments and no return values 若要返回状态，操作方法如下\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) os.Exit(0) // 返回值 } 这样又可以正常运行了\n当然，返回值也可以定义为一个异常值，如-1\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) os.Exit(-1) // 异常返回 } 运行结果如下\nHello, World! exit status 255 # 异常状态 2.5.2 传参方面 # C++/Java 可以在main函数传参，args string[] 类型\nGo不可以这样做\nmain()本身就不支持传参 需要通过 os.Args()获取参数 程序实例如下\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { args := os.Args fmt.Println(\u0026#34;Hello, World!\u0026#34;) fmt.Println(args) os.Exit(0) } \u0026gt; go run hello_world.go Hello, World! [/var/folders/s5/lh51989j3qv9nrz2p9tdjc8h0000gn/T/go-build3482274569/b001/exe/hello_world] \u0026gt; go run hello_world.go chao Hello, World! [/var/folders/s5/lh51989j3qv9nrz2p9tdjc8h0000gn/T/go-build2433158551/b001/exe/hello_world chao] 第二个例子\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { if len(os.Args) \u0026gt; 1 { fmt.Println(\u0026#34;Hello, World!\u0026#34;, os.Args[1]) } } \u0026gt; go run hello_world.go ppx Hello, World! ppx ","date":"2024-10-11","externalUrl":null,"permalink":"/golang/golang-basic/chapter-2/","section":"Golangs","summary":"","title":"第二章-开始Golang学习","type":"golang"},{"content":"","date":"2024-10-11","externalUrl":null,"permalink":"/tags/go/","section":"Tags","summary":"","title":"Go","type":"tags"},{"content":"","date":"2024-10-11","externalUrl":null,"permalink":"/tags/golang/","section":"Tags","summary":"","title":"Golang","type":"tags"},{"content":"","date":"2024-10-11","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" 1. 前导篇 # 1.1 不同版本的特性 # 参考文章：Go语言各版本特性回顾（1.5-1.14）-腾讯云开发者社区-腾讯云\n1.2 核心特性 # 1.2.1 Go的特性 # 吸收和接纳其他语言的特性 在开发中，能够抓牢程序员的痛点，以简单直接且高效稳定的方式来解决问题 不仅编译迅速，还具有强大的垃圾收集机制和运行反射机制 快速的、静态类型的编译型语言，又有动态类型解释型语言的感觉 表达能力强：简洁清晰高效 思想：大道至简，小而蕴真 1.2.2 核心特性1-并发编程 # 在当今这个时代，并发编程的意义不言而喻，因此Golang具有以下并发编程特点\n简洁程度要胜过绝大多数语言，这是最大的亮点之一，他也是未来进入高并发高性能场景的重要筹码 不同于传统的多进程和多线程，golang的并发执行单元是一种称为goroutine的协程，语言级别关键字 go用于启动协程，并且在同一台机器上启动成千上百个协程；协程间一般由应用程序显示调度，上下文切换无需下到内核层，使得更加高效，通信靠独有的channel机制实现 1.2.3 内存回收(GC) # 内存自动回收，再也不需要开发人员管理内存。回收过程如下： 首先stop the world, 扫描所有对象判活，把可回收对象在一段bitmap区中标记下来 接着立即start the world，回复服务，同时启动一个专门的gorountine，回收内存到空闲list中以备复用 开发人员专注业务实现，降低心智负担 只需要new分配内存，无需物理释放(它由专门线程顶起来执行)； GC瓶颈在于每次都要扫描所有对象来判活，带收集对象越多，速度越慢；其性能会随版本更新而不断优化 1.2.4 内存分配 # 先分配一块大内存区域 大内存被分成各个大小等级的块，放入不同的空闲list中 对象分配空闲时从空闲list中取出大小合适的内存块 内存回收时，会把不用的内存重放会空闲list 空闲内存机制按照一定策略合并，以减少碎片 1.2.5 编译 # 目前Golang具有两种编译器\nGccgo，建立在GCC基础之上 另一种是针对x64和x86计算机的一套编译器(6g和8g) 依赖管理，在代码中的 import中加上github路径即可，库默认下载到pkg目录上 编译时默认会检查代码中所有尸体的使用情况，凡是没用到的package或变量，一定会编译不通过；这确保了go语言的严谨性 1.2.6 网络编程 # Go语言诞生在互联网时代，故天生就具有去中心化、分布式等特性，其中一个具体表现就是提供了丰富的网络编程接口\nsocket用 net.Dial(基于TCP/UDP，封装了传统的 connect``listen``accept等接口) http用 http.Get()或 http.Post() rpc用 client.Call('class_name.method_name', args, \u0026amp;reply) 重要能力：自带高性能HttpServer，通过几行代码就可以得到一个基于协程的高性能Web服务，更重要的是，维护成本极低，没有任何依赖 1.2.7 函数多返回值 # 这个是Go语言与其他传统语言在函数方面上的其中一个区别\n允许函数返回多个值，在某些场景下，可以有效简化编程 由于其官方推荐在函数返回的最后一个参数为error类（只要在逻辑中体现异常），这才有必要要求允许返回多个值 1.2.8 语言交互性 # 定义：本语言是否可以和其他语言交互，比如可以调用其他语言编译的库 Go可以与C程序交互，交互工具叫Cgo，它还可以允许开发者混合编写C语言代码，然后Cgo工具可以把混写的代码提取并生成对于C功能的调用包装代码，开发者可以完全忽略而这边界如何跨越的 1.2.9 异常处理 # 为防止代码量增加以及被滥用（不管多小的异常都要抛出），Go不支持 try ... catch 块，Go处理方式为 defer...recover...panic\ndefer：函数结束后执行，呈先进后出 panic：程序出现无法修复的错误时使用，但defer要执行完，如除以0 recover：会修复错误，不至于程序种植，如果不确定函数会不会出错，就用defer+recover 若异常严重，由Go语言内部自动抛出，用户无需抛出，如果使用 panic(str)就会退化到try-catch块那种模式 1.2.10 其他特性 # 类的推导，可以用var来定义变量（注意：虽然可以用var，但Go毕竟是强类型语言） interface，一个类型只要实现了某个interface的所有方法，即可实现该interface，无需显示继承；Go编程规范推荐每个接口类只提供1-2个方法，这样使每个接口类的目的非常清晰 defer：Go语言关键字，可通过它指定需要延迟执行的逻辑体（在函数体return前或出现panic执行），这种机制适合善后逻辑处理（如资源泄露） \u0026ldquo;包\u0026quot;的概念：和python相同，把相同功能代码放到一个目录，称之为包，包可以被其他包引用，每个程序只有一个main包供其执行 交叉编译：不受系统限制 ","date":"2024-10-11","externalUrl":null,"permalink":"/golang/golang-basic/chapter-1/","section":"Golangs","summary":"","title":"第一章-Golang简介","type":"golang"},{"content":"","date":"2024-10-11","externalUrl":null,"permalink":"/tags/%E5%9F%BA%E7%A1%80/","section":"Tags","summary":"","title":"基础","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]