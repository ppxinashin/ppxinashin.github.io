[{"content":"","date":"2024-12-30","externalUrl":null,"permalink":"/java/","section":"Javas","summary":"","title":"Javas","type":"java"},{"content":" 前言 # 经过两个月的面试，发现了诸多的问题，现在为了避免应试失败，这一次开始拓展性的面试复盘，把所有面试的问题都准备一下，今天进行的是复盘题目和总结，明天开始逐一攻关\n0. 自我介绍 # 请做一个简单的自我介绍，比如你的职业背景？ - 面试鸭 - 程序员求职面试刷题神器 1. 专业技能部分 # 1.1 专业技能1-熟悉Java特性 # 基础知识\nJava 基础面试题 - 面试鸭 - 程序员求职面试刷题神器 JDK8新特性\nJDK8 有哪些新特性？ - Java 基础面试题 - 面试鸭 - 程序员求职面试刷题神器\nJava 的 Optional 类是什么？它有什么用？ - Java 基础面试题 - 面试鸭 - 程序员求职面试刷题神器\n请解释一下 Java 8 Stream API 和 Lambda 表达式的作用，以及在项目中如何应用它们来简化集合处理？ - 面试鸭 - 程序员求职面试刷题神器\nJava 8 Stream | 菜鸟教程\n集合类\n总\nJava 中有哪些集合类？请简单介绍 - Java 集合面试题 - 面试鸭 - 程序员求职面试刷题神器 Map\n说说 Java 中 HashMap 的原理？ - Java 集合面试题 - 面试鸭 - 程序员求职面试刷题神器\n为什么 JDK 1.8 对 HashMap 进行了红黑树的改动？ - Java 集合面试题 - 面试鸭 - 程序员求职面试刷题神器\nJDK 1.8 对 HashMap 除了红黑树还进行了哪些改动？ - Java 集合面试题 - 面试鸭 - 程序员求职面试刷题神器\nJava 中 ConcurrentHashMap 1.7 和 1.8 之间有哪些区别？ - Java 集合面试题 - 面试鸭 - 程序员求职面试刷题神器\nConcurrentHashMap 和 Hashtable 的区别是什么？ - Java 集合面试题 - 面试鸭 - 程序员求职面试刷题神器\nJava 中的 HashMap 和 Hashtable 有什么区别？ - Java 集合面试题 - 面试鸭 - 程序员求职面试刷题神器\n什么是 Hash 碰撞？怎么解决哈希碰撞？ - Java 集合面试题 - 面试鸭 - 程序员求职面试刷题神器\nJava 中 HashMap 的扩容机制是怎样的？ - Java 集合面试题 - 面试鸭 - 程序员求职面试刷题神器\nJava 中 ConcurrentHashMap 的 get 方法是否需要加锁？ - Java 集合面试题 - 面试鸭 - 程序员求职面试刷题神器\nJava 中的 WeakHashMap 是什么 ？ - Java 集合面试题 - 面试鸭 - 程序员求职面试刷题神器\nList\nJava ArrayList 的扩容机制是什么？ - Java 集合面试题 - 面试鸭 - 程序员求职面试刷题神器\nJava 中的 List 接口有哪些实现类？ - Java 集合面试题 - 面试鸭 - 程序员求职面试刷题神器\nJava 中 ArrayList 和 LinkedList 有什么区别？ - Java 集合面试题 - 面试鸭 - 程序员求职面试刷题神器\n数组和链表在 Java 中的区别是什么？ - Java 集合面试题 - 面试鸭 - 程序员求职面试刷题神器\nJava 中的 CopyOnWriteArrayList 是什么？ - Java 集合面试题 - 面试鸭 - 程序员求职面试刷题神器\n你遇到过 ConcurrentModificationException 错误吗？它是如何产生的？ - Java 集合面试题 - 面试鸭 - 程序员求职面试刷题神器\nSet\nJava 中的 HashSet 和 HashMap 有什么区别？ - Java 集合面试题 - 面试鸭 - 程序员求职面试刷题神器 其他题目\nJava 集合面试题 - 面试鸭 - 程序员求职面试刷题神器 自定义注解\nJava 中的注解原理是什么？ - Java 基础面试题 - 面试鸭 - 程序员求职面试刷题神器\n你使用过 Java 的反射机制吗？如何应用反射？ - 面试鸭 - 程序员求职面试刷题神器\n异常处理\nJava 中 Exception 和 Error 有什么区别？ - Java 基础面试题 - 面试鸭 - 程序员求职面试刷题神器\nJava 运行时异常和编译时异常之间的区别是什么？ - Java 基础面试题 - 面试鸭 - 程序员求职面试刷题神器\nJava常见的10个异常 - 尐J - 博客园\nLambda编程\n请解释一下 Java 8 Stream API 和 Lambda 表达式的作用，以及在项目中如何应用它们来简化集合处理？ - 面试鸭 - 程序员求职面试刷题神器\nJava Lambda 表达式 | 菜鸟教程\n1.2 专业技能2-第三方类库和框架 # 略，没有考题 1.3 专业技能3-Spring + MyBatis # Spring\nSpring 的优点 - Spring 面试题 - 面试鸭 - 程序员求职面试刷题神器\n什么是 Spring IOC？ - Spring 面试题 - 面试鸭 - 程序员求职面试刷题神器\nSpring IOC 有什么好处？ - Spring 面试题 - 面试鸭 - 程序员求职面试刷题神器\n什么是 AOP？ - Spring 面试题 - 面试鸭 - 程序员求职面试刷题神器\nSpring AOP默认用的是什么动态代理，两者的区别？ - Spring 面试题 - 面试鸭 - 程序员求职面试刷题神器\nSpring AOP 和 AspectJ 有什么区别？ - Spring 面试题 - 面试鸭 - 程序员求职面试刷题神器\n什么是循环依赖（常问）？ - Spring 面试题 - 面试鸭 - 程序员求职面试刷题神器\nSpring 如何解决循环依赖？ - Spring 面试题 - 面试鸭 - 程序员求职面试刷题神器\n为什么 Spring 循环依赖需要三级缓存，二级不够吗？ - Spring 面试题 - 面试鸭 - 程序员求职面试刷题神器\n能说说 Spring 拦截链的实现吗？ - Spring 面试题 - 面试鸭 - 程序员求职面试刷题神器\nSpring 一共有几种注入方式？ - Spring 面试题 - 面试鸭 - 程序员求职面试刷题神器\n说下 Spring Bean 的生命周期？ - Spring 面试题 - 面试鸭 - 程序员求职面试刷题神器\nSpring 事务有几个隔离级别？ - Spring 面试题 - 面试鸭 - 程序员求职面试刷题神器\nSpring 有哪几种事务传播行为? - Spring 面试题 - 面试鸭 - 程序员求职面试刷题神器\nSpring 事务传播行为有什么用? - Spring 面试题 - 面试鸭 - 程序员求职面试刷题神器\nSpring 事务在什么情况下会失效？ - Spring 面试题 - 面试鸭 - 程序员求职面试刷题神器\n@Component、@Controller、@Repository和@Service 的区别？ - Spring 面试题 - 面试鸭 - 程序员求职面试刷题神器\n说说 Spring 启动过程？ - Spring 面试题 - 面试鸭 - 程序员求职面试刷题神器\nSpring 面试题 - 面试鸭 - 程序员求职面试刷题神器\nSpring Boot\n什么是 Spring Boot？ - SpringBoot 面试题 - 面试鸭 - 程序员求职面试刷题神器\n说说 Springboot 的启动流程？ - SpringBoot 面试题 - 面试鸭 - 程序员求职面试刷题神器\nSpring Boot 是如何通过 main 方法启动 web 项目的？ - SpringBoot 面试题 - 面试鸭 - 程序员求职面试刷题神器\n如何理解 Spring Boot 中的 starter？ - SpringBoot 面试题 - 面试鸭 - 程序员求职面试刷题神器\n如何在 SpringBoot 启动时执行特定代码？有哪些方式？ - SpringBoot 面试题 - 面试鸭 - 程序员求职面试刷题神器\nSpring Boot 中 application.properties 和 application.yml 的区别是什么？ - SpringBoot 面试题 - 面试鸭 - 程序员求职面试刷题神器\nSpring Boot 配置文件加载优先级你知道吗？ - SpringBoot 面试题 - 面试鸭 - 程序员求职面试刷题神器\nSpringBoot 是如何实现自动配置的？ - SpringBoot 面试题 - 面试鸭 - 程序员求职面试刷题神器\n如何在 Spring Boot 中定义和读取自定义配置？ - SpringBoot 面试题 - 面试鸭 - 程序员求职面试刷题神器\nSpringBoot（Spring）中为什么不推荐使用 @Autowired ？ - SpringBoot 面试题 - 面试鸭 - 程序员求职面试刷题神器\n在 Spring Boot 中你是怎么使用拦截器的？ - SpringBoot 面试题 - 面试鸭 - 程序员求职面试刷题神器\nSpring Boot 如何处理跨域请求（CORS）？ - SpringBoot 面试题 - 面试鸭 - 程序员求职面试刷题神器\nSpringBoot 中如何实现定时任务 ? - SpringBoot 面试题 - 面试鸭 - 程序员求职面试刷题神器\nSpring Boot 是否可以使用 XML 配置 ? - SpringBoot 面试题 - 面试鸭 - 程序员求职面试刷题神器\nSpring Boot 支持哪些嵌入 Web 容器？ - SpringBoot 面试题 - 面试鸭 - 程序员求职面试刷题神器\nSpring Boot 打成的 jar 和普通的 jar 有什么区别 ? - SpringBoot 面试题 - 面试鸭 - 程序员求职面试刷题神器\nSpring Boot 3.x 与 2.x 版本有哪些主要的改进和区别？ - SpringBoot 面试题 - 面试鸭 - 程序员求职面试刷题神器\nSpring Boot注解总结大全【案例详解，一眼秒懂】-CSDN博客\nSpringBoot 面试题 - 面试鸭 - 程序员求职面试刷题神器\nSpring Cloud (包括 Alibaba, Nacos, Open Feign和Gateway)\nSpring Boot 和 Spring Cloud 之间的区别？ - SpringCloud 面试题 - 面试鸭 - 程序员求职面试刷题神器\n什么是 Spring Cloud Alibaba？它和 Spring Cloud 有什么区别？由哪些核心技术组成？ - OJ 判题项目面试题 - 面试鸭 - 程序员求职面试刷题神器\nSpring Cloud 的优缺点有哪些？ - SpringCloud 面试题 - 面试鸭 - 程序员求职面试刷题神器\n你知道 Nacos 配置中心的实现原理吗？ - SpringCloud 面试题 - 面试鸭 - 程序员求职面试刷题神器\n什么是配置中心？有哪些常见的配置中心？ - SpringCloud 面试题 - 面试鸭 - 程序员求职面试刷题神器\nEureka、Zookeeper、Nacos、Consul 的区别？ - SpringCloud 面试题 - 面试鸭 - 程序员求职面试刷题神器\nSpring Cloud 由什么组成？ - SpringCloud 面试题 - 面试鸭 - 程序员求职面试刷题神器\n你是怎么理解微服务的？ - SpringCloud 面试题 - 面试鸭 - 程序员求职面试刷题神器\nNacos 中的 Namespace 是什么？ - SpringCloud 面试题 - 面试鸭 - 程序员求职面试刷题神器\n为什么需要负载均衡？ - SpringCloud 面试题 - 面试鸭 - 程序员求职面试刷题神器\n负载均衡的实现方式有哪些？ - SpringCloud 面试题 - 面试鸭 - 程序员求职面试刷题神器\nHTTP 与 RPC 之间的区别？ - SpringCloud 面试题 - 面试鸭 - 程序员求职面试刷题神器\n什么是 Feign？ - SpringCloud 面试题 - 面试鸭 - 程序员求职面试刷题神器\nFeign 是如何实现负载均衡的？ - SpringCloud 面试题 - 面试鸭 - 程序员求职面试刷题神器\n为什么 Feign 第一次调用耗时很长？ - SpringCloud 面试题 - 面试鸭 - 程序员求职面试刷题神器\nFeign 和 OpenFeign 的区别？ - SpringCloud 面试题 - 面试鸭 - 程序员求职面试刷题神器\n什么是 Spring Cloud Gateway？ - SpringCloud 面试题 - 面试鸭 - 程序员求职面试刷题神器\n你项目里为什么选择 Gateway 作为网关？ - SpringCloud 面试题 - 面试鸭 - 程序员求职面试刷题神器\n说说什么是 API 网关？它有什么作用？ - SpringCloud 面试题 - 面试鸭 - 程序员求职面试刷题神器\n什么是服务雪崩？ - 面试鸭 - 程序员求职面试刷题神器\nSpring Cloud - 面试鸭 - 程序员求职面试刷题神器\nMyBatis/MBP\nMyBatis 面试题 - 面试鸭 - 程序员求职面试刷题神器 1.4 专业技能4-数据库 # MySQL 面试题 - 面试鸭 - 程序员求职面试刷题神器\nRedis 面试题 - 面试鸭 - 程序员求职面试刷题神器\n1.5 专业技能5-消息队列 # 共识\n消息队列面试题 - 面试鸭 - 程序员求职面试刷题神器 RabbitMQ\nRabbitMQ 面试题 - 面试鸭 - 程序员求职面试刷题神器 1.6 专业技能6-架构模式 # 面向对象设计模式\n什么是设计模式？请简述其作用。 - 设计模式面试题 - 面试鸭 - 程序员求职面试刷题神器\n策略模式\n什么是策略模式？一般用在什么场景？ - 设计模式面试题 - 面试鸭 - 程序员求职面试刷题神器\n为什么使用策略模式来封装不同语言的判题算法，它有哪些好处？具体如何实现？ - 面试鸭 - 程序员求职面试刷题神器\n为什么使用策略模式来封装不同的应用评分算法？它有哪些好处？具体如何实现？ - 面试鸭 - 程序员求职面试刷题神器\n工厂模式\n请描述简单工厂模式的工作原理。 - 设计模式面试题 - 面试鸭 - 程序员求职面试刷题神器\n工厂模式和抽象工厂模式有什么区别？ - 设计模式面试题 - 面试鸭 - 程序员求职面试刷题神器\n单例\n请解释什么是单例模式，并给出一个使用场景 - 设计模式面试题 - 面试鸭 - 程序员求职面试刷题神器\n单例模式有哪几种实现？如何保证线程安全？ - 面试鸭 - 程序员求职面试刷题神器\n建造者\n什么是建造者模式？一般用在什么场景？ - 设计模式面试题 - 面试鸭 - 程序员求职面试刷题神器 （注：通义AI的SDK，调用AI能力的API-key和AppID的方法用的是建造者模式） 架构模式\nVue 中 MVVM、MVC 和 MVP 模式的区别是什么？ - 面试鸭 - 程序员求职面试刷题神器 1.7 虚拟机 # Java 虚拟机面试题 - 面试鸭 - 程序员求职面试刷题神器 1.8 三高（高并发、高可用、高性能） # Java 并发面试题 - 面试鸭 - 程序员求职面试刷题神器 2. 项目经历 # 2.1 AI答题 # AI 答题平台项目面试题 - 面试鸭 - 程序员求职面试刷题神器 2.2 OJ # OJ 判题项目面试题 - 面试鸭 - 程序员求职面试刷题神器 3. 算法题/编程题 # 面试经典 150 题 - 学习计划 - 力扣（LeetCode）全球极客挚爱的技术成长平台\n把简单和中等的攻下来就行\n4. 场景题 # 八股文变形，目前会总结面试过的场景题，并给出思路 5. HR面试 # 5.1 开放问题 # 你有什么想要问我们的问题？比如想了解我们公司的哪些情况？ - 面试鸭 - 程序员求职面试刷题神器 5.2 前途问题 # 你选择这份工作的主要动机和原因是什么？ - 面试鸭 - 程序员求职面试刷题神器\n你对我们公司的情况了解多少？ - 面试鸭 - 程序员求职面试刷题神器\n如果你在这次面试中未能被录用，你会怎么做？比如怎么调整求职计划 - 面试鸭 - 程序员求职面试刷题神器\n5.3 涨薪谈判 # 面试到了谈薪环节，这么谈薪，工资至少可多涨10%！高于预期 ","date":"2024-12-30","externalUrl":null,"permalink":"/java/interview/review/","section":"Javas","summary":"","title":"复盘与复习","type":"java"},{"content":"","date":"2024-12-30","externalUrl":null,"permalink":"/","section":"热河fen青","summary":"","title":"热河fen青","type":"page"},{"content":"\n\n","date":"2024-12-13","externalUrl":null,"permalink":"/posts/","section":"全部帖子","summary":"","title":"全部帖子","type":"posts"},{"content":"\n\n","date":"2024-12-12","externalUrl":null,"permalink":"/java/interview/","section":"Javas","summary":"","title":"Java面经","type":"java"},{"content":" 一面 # 聊天为主，偶尔聊点技术问题（意外）\n自我介绍\n请做一个简短的自我介绍。 项目经验\n您最近参与的一个项目是什么？该项目的主要技术栈是什么？ 智能答题系统是否已经上线？如果上线了，在哪里上线？ 在这个项目中您具体工作了多久？ 团队与职责\n您所在的团队有多少人？您的小组有多少人？ 请描述一下您在高校GPT系统中的角色和责任。 在这些项目中，您主要负责哪些方面的工作？ 编程语言和技术细节\n在项目中您使用到了Java的哪些特性？ 抽象类在Java中有何特点？它们与接口有何不同？ 参考：https://blog.csdn.net/ADbyCool/article/details/106789587 类（非接口类）在Java中有什么特性？ 在项目中您是否有抽象过任何方法？如果有，请举例说明。 设计模式\n请解释一下什么是策略模式，以及它在您的项目中是如何应用的？ 策略模式适用于哪些场景？请提供一个实际例子。 在评分系统中，策略模式如何帮助简化代码？ 数据库相关\nMySQL中的组件和索引之间有什么区别？ 哪些数据类型不适合创建索引，为什么？ 在什么情况下索引会失效？ 数据结构和算法\nHashMap的工作原理是什么？ HashMap是线程安全的吗？如果不是，有哪些线程安全的替代品？ 生产问题解决\n在AI系统或GPT系统的生产环境中遇到过哪些问题？如何解决这些问题？ 实时交互技术\n在确保前后端保持实时连接时，采用了哪些技术？这些技术对服务器的压力有多大？ 部署和CI/CD\n项目的部署方式是什么？有使用到CI/CD工具吗？如果是的话，具体是哪些工具？ 技术选型\n项目中使用了哪些特定的技术栈？比如RPC框架、微服务管理等。 以上问题涵盖了从个人背景、项目经历、技术细节到问题解决能力等多个方面的考察。\n二面 # ","date":"2024-12-11","externalUrl":null,"permalink":"/java/interview/zhbx-wb/","section":"Javas","summary":"","title":"中华保险外包（福利较好）-北京","type":"java"},{"content":" 笔试题（只记录我没答上来的题目） # 1. 外语类 # 外语完型 # 全是蒙的，几乎一个都没答上来 2. 算法 # 给定二叉树的一个后序和中序遍历结果，确定前序遍历结果 # 要确定二叉树的前序遍历结果，可以按照以下步骤进行：\n后序遍历的最后一个节点是根节点：从后序遍历结果中找到最后一个节点，这个节点就是二叉树的根节点。 在中序遍历中找到根节点的位置：在中序遍历结果中找到这个根节点的位置，这样可以将中序遍历结果分成左子树和右子树两部分。 递归构建左子树和右子树： 对于左子树，使用中序遍历结果的左部分和后序遍历结果的前部分（去掉最后一个节点）。 对于右子树，使用中序遍历结果的右部分和后序遍历结果的中间部分（去掉最后一个节点）。 组合前序遍历结果：根节点 + 左子树的前序遍历结果 + 右子树的前序遍历结果。 给定一个满二叉树，求深度为n的二叉树叶节点有多少个？ # 对于一个深度为n的满二叉树，其叶节点的数量为 \\(2^{(n-1)}\\)。\n这是因为满二叉树的每一层节点数是前一层节点数的两倍，而叶节点位于最后一层。\n3. 数学题 # 排列组合题 # 这他妈都高中的知识，高考完早扔了\n题目描述：\n已知：有ABCDEFG七个元素\n希望A一直在B的左侧（两个元素可以不挨着），有几种排列方式？ 希望A一直在B的左侧（两个元素必须紧挨），有几种排列方式？ 对于这两个问题，我们可以用组合数学的方法来解决。\n当A必须在B的左侧但两者不必紧挨着时： 我们有7个不同的元素，所以如果没有其他限制条件，这7个元素可以以7!（7的阶乘）种方式排列。但是这里有一个限制条件：A必须在B的左侧。对于A和B来说，它们只有两种相对位置——要么A在B的左边，要么B在A的左边。由于这两种情况是等可能的，并且只有一种符合我们的要求，所以我们只需要计算出所有排列的一半即可得到答案。因此，总的排列方式为7! / 2。\n\\( \\text{总排列数} = \\frac{7!}{2} = \\frac{5040}{2} = 2520 \\)\n当A必须在B的左侧且两者必须紧挨着时： 我们可以把A和B看作一个整体（AB），这样就变成了6个“元素”（AB, C, D, E, F, G）的排列问题。6个不同元素的排列方式为6!。由于A和B在这个情况下只能以一种顺序出现（即AB，不能BA），我们不需要再做额外的除法或乘法。\n\\( \\text{总排列数} = 6! = 720 \\)\n综上所述：\n在第一种情况下，有2520种排列方式。 在第二种情况下，有720种排列方式。 其他的题目暂时回忆不起来，都是一些基础题，背一背就好了\n面试题（20min左右） # 不具备参考价值，看看就行，挺水的：\n自我介绍 项目讲述 场景题：链式调用API的问题 这个最终还是拒了，首先宁可饿死也不会选这家企业，黑幕比较多，甲乙方公司都有非常严重的问题，而且福州这个城市宜居度还是比较差的，我只是拿这个面试刷刷自己的熟练度，没想到会水成这个样子\n","date":"2024-12-11","externalUrl":null,"permalink":"/java/interview/xysj-bs-wb/","section":"Javas","summary":"","title":"兴业数金-外包-福州","type":"java"},{"content":" 0. 结果 # 没啥戏\n1. 面试 # 1. 技术栈和项目经验： # 你在之前的项目中使用了哪些技术栈？ # 描述一下你最近做的AI答题应用系统。 # 2. AI模型选择： # 在选型过程中是如何选择用哪一个AI模型（如通义AI、OpenAI等）？ # 3. Spring Boot配置与操作： # 如果想将Spring Boot默认的嵌入式服务器换成其他的应该怎么做？ # 如何在Spring Boot启动时执行特定的代码逻辑？ # 4. 异常处理： # 你是如何实现全局异常处理的？ # 5. 加密机制： # 对controller返回值进行加密的方法有哪些？ # 要在Spring Boot启动后立即对controller返回值进行加密，可以使用拦截器或过滤器来实现。以下是使用过滤器的示例：\n创建加密工具类：\nimport javax.crypto.Cipher; import javax.crypto.spec.SecretKeySpec; import java.util.Base64; public class EncryptionUtil { private static final String KEY = \u0026#34;1234567890123456\u0026#34;; // 16-byte key public static String encrypt(String data) throws Exception { SecretKeySpec secretKey = new SecretKeySpec(KEY.getBytes(), \u0026#34;AES\u0026#34;); Cipher cipher = Cipher.getInstance(\u0026#34;AES\u0026#34;); cipher.init(Cipher.ENCRYPT_MODE, secretKey); byte[] encryptedData = cipher.doFinal(data.getBytes()); return Base64.getEncoder().encodeToString(encryptedData); } } 创建过滤器：\nimport org.springframework.stereotype.Component; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @Component public class EncryptionFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { // 初始化 } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { EncryptionResponseWrapper responseWrapper = new EncryptionResponseWrapper((HttpServletResponse) response); chain.doFilter(request, responseWrapper); String originalContent = new String(responseWrapper.getDataStream()); try { String encryptedContent = EncryptionUtil.encrypt(originalContent); response.getOutputStream().write(encryptedContent.getBytes()); } catch (Exception e) { throw new ServletException(\u0026#34;加密失败\u0026#34;, e); } } @Override public void destroy() { // 销毁 } } 创建响应包装类：\nimport javax.servlet.ServletOutputStream; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpServletResponseWrapper; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.PrintWriter; public class EncryptionResponseWrapper extends HttpServletResponseWrapper { private ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); private PrintWriter writer = new PrintWriter(outputStream); public EncryptionResponseWrapper(HttpServletResponse response) { super(response); } @Override public ServletOutputStream getOutputStream() throws IOException { return new ServletOutputStream() { @Override public void write(int b) throws IOException { outputStream.write(b); } }; } @Override public PrintWriter getWriter() throws IOException { return writer; } public byte[] getDataStream() { writer.flush(); return outputStream.toByteArray(); } } 配置过滤器： 确保Spring Boot应用程序能够扫描到过滤器组件，可以在@SpringBootApplication类所在包或其子包中放置过滤器类，Spring Boot会自动扫描并注册过滤器。\n这样，当Spring Boot应用程序启动后，所有controller返回的内容都会通过过滤器进行加密。\n6. 事务管理： # @Transactional注解在什么情况下会失效？ # 方法不是 public 的：@Transactional 只能应用于 public 方法。 方法被 final 修饰：Spring AOP 代理无法代理 final 方法。 类被 final 修饰：Spring AOP 代理无法代理 final 类。 方法在同一个类中被调用：如果在同一个类中调用带有 @Transactional 注解的方法，事务不会生效，因为 Spring AOP 代理不会拦截内部方法调用。 事务管理器配置错误：如果事务管理器配置不正确，事务也不会生效。 异常类型不匹配：默认情况下，只有未检查异常（继承自 RuntimeException）才会触发事务回滚。如果抛出的是检查异常（继承自 Exception），事务不会回滚，除非在 @Transactional 注解中明确指定。 7. MySQL索引： # MySQL的索引在什么情况下会失效？ # 使用了函数：在索引列上使用了函数或表达式，例如 WHERE UPPER(column) = \u0026lsquo;value\u0026rsquo;。 类型不匹配：查询条件中的数据类型与索引列的数据类型不一致。 使用了通配符：在LIKE查询中，如果通配符在前面，例如 LIKE \u0026lsquo;%value\u0026rsquo;。 隐式转换：查询中导致索引列进行隐式类型转换，例如字符串和数字比较。 OR条件：在WHERE子句中使用OR条件且OR两边的列没有同时使用索引。 不等于操作：使用!=或\u0026lt;\u0026gt;操作符。 IS NULL或IS NOT NULL：在索引列上使用IS NULL或IS NOT NULL。 前缀索引：在前缀索引中，查询条件未使用前缀的全部长度。 范围查询：在复合索引中，使用范围查询（如BETWEEN、\u0026lt;、\u0026gt;）后面的列索引失效。 数据量小：表的数据量太小，MySQL可能会选择全表扫描而不是使用索引。 8. Linux服务器操作： # 你平时对Linux服务器有具体的操作吗？比如部署程序后CPU占用率特别高，如何排查这个问题? # 要排查部署程序后CPU占用率特别高的问题，可以按照以下步骤进行\n监控和日志：首先查看系统监控工具（如Windows的任务管理器或Linux的top命令）和应用程序日志，确定哪个进程占用了大量的CPU资源。 分析代码：检查代码中是否有死循环、递归调用、密集计算等可能导致高CPU占用的部分。 性能分析工具：使用性能分析工具（如Visual Studio Profiler、Perf、JProfiler等）对应用程序进行性能分析，找出CPU热点。 优化代码：根据性能分析的结果，优化代码，减少不必要的计算和资源占用。 检查依赖：检查第三方库或依赖项是否存在性能问题，尝试更新或替换它们。 配置调整：调整应用程序的配置参数，如线程池大小、缓存设置等，以优化性能。 硬件资源：确保服务器硬件资源（如CPU、内存）充足，必要时考虑升级硬件。 通过以上步骤，可以逐步排查和解决CPU占用率高的问题。 9. Java内存分析： # Java程序内存占用高时，如何dump一个内存文件出来？ # 要在Java程序内存占用高时dump一个内存文件，可以使用以下几种方法：\n使用jmap工具： jmap是JDK自带的工具，可以用来生成Java堆的转储文件。命令如下：\njmap -dump:live,format=b,file=heapdump.hprof \u0026lt;pid\u0026gt; 其中，\u0026lt;pid\u0026gt;是Java进程的ID，可以通过jps命令获取。\n使用jcmd工具： jcmd也是JDK自带的工具，可以用来生成Java堆的转储文件。命令如下：\njcmd \u0026lt;pid\u0026gt; GC.heap_dump heapdump.hprof 其中，\u0026lt;pid\u0026gt;是Java进程的ID。\n使用VisualVM： VisualVM是一个可视化的工具，可以用来监控和分析Java应用程序的性能。可以通过以下步骤生成堆转储文件：\n打开VisualVM并连接到目标Java进程。 在“监视”选项卡中，点击“堆转储”按钮。 在代码中触发堆转储： 可以在Java代码中使用com.sun.management.HotSpotDiagnosticMXBean来生成堆转储文件。示例如下：\nimport com.sun.management.HotSpotDiagnosticMXBean; import java.lang.management.ManagementFactory; public class HeapDump { public static void dumpHeap(String filePath, boolean live) throws Exception { HotSpotDiagnosticMXBean mxBean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class); mxBean.dumpHeap(filePath, live); } public static void main(String[] args) throws Exception { dumpHeap(\u0026#34;heapdump.hprof\u0026#34;, true); } } 通过以上方法，可以在Java程序内存占用高时生成堆转储文件，以便进行进一步的分析。\n10. Redis持久化和哨兵模式： # Redis的持久化方式有哪些？ # RDB（Redis Database）：将数据集的快照在指定的时间间隔保存到磁盘上。适合做数据备份和灾难恢复。 AOF（Append Only File）：通过记录每个写操作来实现持久化。可以更频繁地保存数据，提供更高的数据安全性。 介绍一下Redis的哨兵模式 # Redis的哨兵模式（Sentinel）是一种用于管理Redis集群的高可用性解决方案。它的主要功能包括：\n监控（Monitoring）：哨兵会持续检查主服务器和从服务器是否正常工作。 通知（Notification）：当被监控的Redis服务器出现问题时，哨兵会通过API向系统管理员或其他应用程序发送通知。 自动故障转移（Automatic Failover）：当主服务器出现故障时，哨兵会自动将一个从服务器提升为新的主服务器，并将其他从服务器重新配置为复制新的主服务器。 配置提供者（Configuration Provider）：客户端可以连接到哨兵来获取当前Redis集群的主服务器地址。 哨兵模式好处 # 高可用性：通过自动故障转移，确保Redis服务的高可用性。 监控和通知：实时监控Redis实例的状态，并在出现问题时及时通知。 自动化管理：减少了人工干预，提升了系统的可靠性和稳定性。 扩展性：可以轻松地添加更多的哨兵实例来提高系统的容错能力。 哨兵模式使得Redis在生产环境中更加可靠和易于管理。\n主观下线和客观下线的概念是什么？ # 在 Redis 集群中，主观下线和客观下线是两种不同的节点故障检测机制：\n主观下线（Subjective Down, SDOWN）：\n当一个节点认为另一个节点不可用时，就会将其标记为主观下线。 这是一个单个节点的判断，可能是由于网络分区、节点故障等原因导致的。 主观下线的判断是由节点自身的检测机制（如心跳检测）决定的。 客观下线（Objective Down, ODOWN）：\n当集群中多数节点（通常是超过半数）都认为某个节点不可用时，该节点会被标记为客观下线。 客观下线是通过集群中的节点之间相互通信和投票机制决定的。 一旦节点被标记为客观下线，集群会进行故障转移（failover），将该节点的主节点角色转移到其他从节点上。 这两种机制共同作用，确保 Redis 集群能够在节点故障时快速响应并进行相应的处理。\n11. 消息队列MQ： # 使用的消息队列工作模式是什么？ # 消息队列的工作模式有多种，常见的包括以下几种：\n点对点模式（P2P）：消息从一个生产者发送到一个消费者。每条消息只能被一个消费者消费。\n发布/订阅模式（Pub/Sub）：消息从一个生产者发送到多个消费者。每条消息可以被多个消费者消费。\n工作队列模式（Work Queue）：消息从一个生产者发送到多个消费者，但每条消息只能被一个消费者消费。常用于任务分发。\n广播模式（Fanout）：消息从一个生产者发送到所有绑定到该队列的消费者。每条消息会被所有消费者消费。\n主题模式（Topic）：消息根据主题发送到不同的消费者。消费者可以订阅感兴趣的主题，只有匹配的消息才会被消费。\n不同的消息队列系统（如RabbitMQ、Kafka、ActiveMQ等）可能会有不同的实现和特性。\n如何防止消息丢失？(已背过) # 如果MQ挂了但消息还未被消费，怎么办？ # 如果消息队列（MQ）崩溃了但消息还未被消费，可以采取以下措施来处理这种情况：\n消息持久化：确保消息在发送到队列时被持久化到磁盘，这样即使MQ崩溃，重启后也能恢复未消费的消息。例如，RabbitMQ可以使用持久化队列和持久化消息来实现这一点。\n消息确认机制：使用消息确认机制（Acknowledgment），确保只有在消费者确认收到并处理了消息后，消息才会从队列中删除。如果MQ崩溃，未确认的消息会在重启后重新投递给消费者。\n高可用性配置：配置MQ的高可用性（HA），例如使用集群或镜像队列，确保即使一个节点崩溃，其他节点仍能继续提供服务。\n死信队列（DLQ）：配置死信队列，将无法处理或多次投递失败的消息转移到死信队列中，以便后续分析和处理。\n监控和报警：设置监控和报警机制，及时发现MQ的异常情况，并快速响应和处理。\n以下是一个简单的RabbitMQ配置示例，展示了如何启用消息持久化和确认机制：\nimport com.rabbitmq.client.*; public class MQExample { private final static String QUEUE_NAME = \u0026#34;exampleQueue\u0026#34;; public static void main(String[] argv) throws Exception { ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\u0026#34;localhost\u0026#34;); try (Connection connection = factory.newConnection(); Channel channel = connection.createChannel()) { // 声明持久化队列 boolean durable = true; channel.queueDeclare(QUEUE_NAME, durable, false, false, null); String message = \u0026#34;Hello World!\u0026#34;; // 发送持久化消息 channel.basicPublish(\u0026#34;\u0026#34;, QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes()); System.out.println(\u0026#34; [x] Sent \u0026#39;\u0026#34; + message + \u0026#34;\u0026#39;\u0026#34;); // 消费者 DeliverCallback deliverCallback = (consumerTag, delivery) -\u0026gt; { String receivedMessage = new String(delivery.getBody(), \u0026#34;UTF-8\u0026#34;); System.out.println(\u0026#34; [x] Received \u0026#39;\u0026#34; + receivedMessage + \u0026#34;\u0026#39;\u0026#34;); // 确认消息 channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); }; boolean autoAck = false; // 关闭自动确认 channel.basicConsume(QUEUE_NAME, autoAck, deliverCallback, consumerTag -\u0026gt; { }); } } } 通过上述配置，即使RabbitMQ崩溃，未被确认的消息也会在重启后重新投递给消费者。\n12. 分布式锁： # 分布式锁的自动续期是怎么做的？ # 好的，以下是使用Redisson实现分布式锁自动续期的示例代码：\nimport org.redisson.Redisson; import org.redisson.api.RLock; import org.redisson.api.RedissonClient; import org.redisson.config.Config; import java.util.concurrent.TimeUnit; public class DistributedLockExample { private static RedissonClient redissonClient; public static void main(String[] args) { // 配置Redisson Config config = new Config(); config.useSingleServer().setAddress(\u0026#34;redis://127.0.0.1:6379\u0026#34;); redissonClient = Redisson.create(config); // 获取锁 RLock lock = redissonClient.getLock(\u0026#34;myLock\u0026#34;); try { // 尝试获取锁，等待时间为100毫秒，锁过期时间为10秒 if (lock.tryLock(100, 10, TimeUnit.SECONDS)) { try { // 执行需要加锁的任务 System.out.println(\u0026#34;Lock acquired, executing task...\u0026#34;); Thread.sleep(15000); // 模拟任务执行时间 } finally { lock.unlock(); System.out.println(\u0026#34;Lock released.\u0026#34;); } } else { System.out.println(\u0026#34;Failed to acquire lock.\u0026#34;); } } catch (InterruptedException e) { e.printStackTrace(); } finally { redissonClient.shutdown(); } } } 在这个示例中，Redisson 提供了自动续期的功能，当你获取锁时，Redisson会自动在后台线程中续期锁的过期时间，直到显式释放锁。这样可以确保锁在任务执行期间不会过期。\n悲观锁和乐观锁的区别，并举例说明Java中的用法。 # 悲观锁和乐观锁是两种并发控制策略，它们的主要区别在于对待并发冲突的态度不同。\n悲观锁：\n态度：假设会发生并发冲突，因此在操作数据之前先加锁，以确保只有一个线程能够访问数据。 实现：在Java中，悲观锁通常通过synchronized关键字或ReentrantLock来实现。 示例： public class PessimisticLockExample { private final ReentrantLock lock = new ReentrantLock(); public void performTask() { lock.lock(); try { // 需要同步的代码 } finally { lock.unlock(); } } } 乐观锁：\n态度：假设不会发生并发冲突，因此不加锁，而是在提交操作时检查是否有冲突，如果有则重试。 实现：在Java中，乐观锁通常通过java.util.concurrent.atomic包中的原子变量（如AtomicInteger）或版本号机制来实现。 示例： import java.util.concurrent.atomic.AtomicInteger; public class OptimisticLockExample { private final AtomicInteger value = new AtomicInteger(0); public void performTask() { int oldValue, newValue; do { oldValue = value.get(); newValue = oldValue + 1; } while (!value.compareAndSet(oldValue, newValue)); } } 总结：\n悲观锁适用于写操作多、冲突概率高的场景。 乐观锁适用于读操作多、冲突概率低的场景。 13. 安全性考虑： # 提供对外接口时从安全性的角度考虑了哪些方面？ # 单一认证机制（肌肉记忆，因为经常做，所以在说的时候容易被忽视） 敏感信息加密 线程安全 etc. 14. 性能优化与故障排查： # 当页面访问变慢时，你会从哪些方面去排查？ # 慢SQL 若涉及API，看是不是API的问题，要不要加超时机制 文件上传 15. 自主提问： # 公司主要用到的技术栈是什么？（Java, SpringBoot, Netty, etc.） # 入职后可能会做哪些类型的工作？(开发) # 关于产品的愿景和发展方向是怎样的？（官网） # ","date":"2024-12-10","externalUrl":null,"permalink":"/java/interview/zzy/","section":"Javas","summary":"","title":"自研移动端安全产品-指掌易-大连-面试经验","type":"java"},{"content":" 0. 结论 # 疑似刷KPI，因为我和HR核实，大约面试就20分钟，不过线上面试，可以拿来练手\n1. 面试题（20min+） # 自我介绍 项目介绍 Controller 与 RestController的区别（一个是单独注解，另一个是合并注解，后者是ResponseBody与Controller的合并） 问我如何对SQL调优 问我如何解决Redis穿透的问题，缓存搭建的问题 重复性的恶意请求，如果这个缓存就是不存在，且数据库查不到，如何解决？（没答上来，做个参考） 请求速率限制：使用速率限制（Rate Limiting）来限制每个IP地址在一定时间内的请求次数。可以使用Nginx、API Gateway等工具来实现。 验证码：在关键操作或频繁请求时，要求用户输入验证码，以防止自动化的 IP黑名单：将频繁发送恶意请求的IP地址加入黑名单，阻止其访问。 缓存空结果：对于不存在的数据，可以将空结果缓存一段时间，防止短时间内重复查询数据库。 请求签名：对请求进行签名验证，确保请求的合法性，防止伪造请求。 监控和报警：设置监控和报警机制，及时发现和处理异常请求。 策略模式 配置Gateway的方法：yaml，必要三个条件：服务名称、端口号和api前缀 已知如果需要动态配置，除了环境变量手段以外，如何用Nacos实现这个过程？ 参考1：Nacos自定义环境变量 参考2：Nacos 配置中心用法 ","date":"2024-12-10","externalUrl":null,"permalink":"/java/interview/cmcc-wb/","section":"Javas","summary":"","title":"移动外派-杭州","type":"java"},{"content":"","date":"2024-11-28","externalUrl":null,"permalink":"/golang/","section":"Golangs","summary":"","title":"Golangs","type":"golang"},{"content":" 面试题 # 自我介绍 项目介绍 MySQL 知识点 场景设计-短链接(30 min)，插入、查询 Java 知识点 Go 知识点 代码题 最长字串，leetcode原题，滑动窗口 ","date":"2024-11-28","externalUrl":null,"permalink":"/golang/interview/wits-od-baidu/","section":"Golangs","summary":"","title":"纬创外派-百度网盘项目-go语言","type":"golang"},{"content":" 面试题 # 自我介绍 - 要求候选人简述自己的背景和经历。 样例：尊敬的面试官，您好。我是XXX，一名拥有2年Java后端开发经验的工程师。最近在XX公司担任后端工程师，主导了多个关键项目的开发与优化。我对Java有深入理解，熟悉集合类、自定义注解及异常处理，并严格遵守阿里编码规范确保代码质量。熟练使用SSM和Spring Boot框架，曾用MyBatis-Plus提升开发效率。掌握了Redis的应用与优化，解决了缓存穿透、一致性问题，并通过Lua脚本实现限流。特别值得一提的是，在构建一个在线答题平台时，我利用Spring Boot整合了Redis缓存、通义AI智能服务、RxJava响应式编程以及SSE实时推送技术。我们团队采用了策略模式提高系统灵活性，封装AI服务简化初始化，优化Prompt保证数据格式化，同时引入Caffeine本地缓存减少重复计算，显著提升了系统性能。此外，我还领导了一次从Java到Go的技术迁移，大幅提高了开发效率并降低了维护成本。我对软件工程充满热情，持续追求技术水平和服务质量的提升。我相信我的背景和技术能力非常适合这个职位，期待能进一步讨论如何为贵公司带来价值。感谢您提供的机会，希望有幸加入贵公司。谢谢！ 项目介绍 - 让候选人详细讲述最近参与的项目，特别是与AI答题系统相关的内容。 继续看看课程，稍作完善 系统并发能力 - 询问智能答题系统的并发处理能力，特别是针对一万多用户的场景。 信口胡说一下，因为我把它包装成了一个高校特供的项目，当然之前有这样的项目 数据处理流程 - 关于答题系统中数据处理的具体流程，尤其是AI判题时的数据存储和检索机制。 不会 数据库索引 - 提问关于MySQL查询语句中使用IN关键字是否触发索引，以及联合索引的使用情况。 需结合实际情况讨论，仍以字段是否有索引为标准 索引下推 最左匹配原则 事务隔离级别 - 考察候选人对数据库事务隔离级别的理解，特别是MySQL的默认隔离级别及其含义。 四大隔离：读已提交、读未提交、可重复读、串行化 默认隔离级别：可重复读 含义：它确保在同一事务中多次读取同一数据集时，结果是一致的。这意味着在事务执行期间，其他事务无法修改这些数据。这个级别可以防止脏读和不可重复读，但可能出现幻读。 MySQL执行计划 - 询问候选人如何查看和解读MySQL的执行计划，用于查询优化。 select_type, type, key, key_len, rows, Extra 查询类型效率 - 讨论MySQL查询类型（如index, range, ref）的效率排序。 参考： ref \u0026gt; range \u0026gt; index const, system：这些查询类型用于单行匹配，效率最高。 eq_ref：用于唯一索引的查询，每次只返回一行。 ref：用于非唯一索引的查询，可能返回多行。 range：用于范围查询，扫描索引的一部分。 index：扫描整个索引。 ALL：全表扫描，效率最低。 测试候选人对Java字符串处理的理解，包括字符串相等性的判断（小场景题，主要是==与equals的区别） 参考：== equals 和 hashCode 是什么，又有怎样的区别？ 扩展问题： String/StringBuilder/StringBuffer的区别。 类加载顺序 - 询问Java中类的静态变量、静态代码块、成员变量、普通代码块、构造方法、(静态方法)的加载顺序。 静态变量和静态代码块 \u0026gt; 成员变量和普通代码块 \u0026gt; 构造方法 (\u0026gt; 静态方法) Java IO - 要求解释Java IO的不同模式，包括传统的阻塞IO、非阻塞IO及AIO，并提及项目中常用的字节流。 问你这个的时候，实际上考官在问的是序列化和反序列化问题 还有文件字节流 还有上面的三种io ","date":"2024-11-28","externalUrl":null,"permalink":"/java/interview/yss-od-icbc/","section":"Javas","summary":"","title":"赢时胜-外派工行面经","type":"java"},{"content":" 1. 自我介绍 # 面试解析：普通人面试指南2024版\n2. 问题回忆 # 介绍一下你拿手的项目？ 遇到的难点 RabbitMQ问题 MySQL事务问题 Java基础类型 深拷贝和浅拷贝 包装类型和值类型 包装类型和值类型属于什么拷贝 JDK 1.8 新特性 流相关问题 流的过滤会不会影响已有的数组 Spring IOC AOP是什么？ Bean注入是属于IOC还是AOP Spring事务问题（没答上来，瞎编引导到MyBatis） 3. 感受 # 这次感觉很社死，答得磕磕巴巴，差点我就要紫砂了，时至今日都没有一张offer.\n4. 假设通过 # 会有个二面，二面是关于写代码的事情，既然没通过就算了\n5. 如何解决心理问题 # 放松，啥也别想，大不了这辈子不工作，躺尸\n","date":"2024-11-28","externalUrl":null,"permalink":"/java/interview/hand-info-tech/","section":"Javas","summary":"","title":"汉得信息-一面凉经（回忆版）-广州","type":"java"},{"content":" 0. 面试结果 # 岗位竞争激烈，只要两个人，凉凉\n1. 自我介绍 # 面试解析：普通人面试指南2024版\n2. 问题（30min+） # 什么是Spring事务 面向对象相关问题 RabbitMQ相关问题（重复、积压、防止丢失、有序性） Redis哨兵集群有关问题 MySQL事务隔离级别、版本并发控制相关问题 JDK1.8新特性 多线程、高并发 其他Spring相关问题 遇到困难的地方？ 自主提问 3. 感受 # HR小哥哥人还怪好叻~ 我出门的时候人家亲自按电梯，还提醒我注意安全啥的，初始印象还算不错\n但是人类嘛，人越是看似对你好，你一定要有所怀疑\n","date":"2024-11-28","externalUrl":null,"permalink":"/java/interview/tfry-basedl-sz/","section":"Javas","summary":"","title":"同方软银-base大连-深圳出长差-面试（单次/回忆版本）","type":"java"},{"content":" 0. 面试结果 # 凉凉，差点以为能过，面试官当时对我印象不错，意难平，决定分享\n1. 自我介绍(1min) # 面试解析：普通人面试指南2024版\n2. 项目相关描述(15min) # 提问点来自简历一部分内容，基本上都是在聊简历有关话题\n印象最深的就是为何不使用WebSocket，而是使用SSE？\n熟悉了SSE技术后，对比上述前后端实时通讯方案。 1）主动轮询其实是一种伪实时，比如每3 秒轮询请求一次，结果后端在 0.1秒就返回了数据，还 要再等 2.9 秒，存在延迟。 2）WebSocket 和 SSE虽然都能实现服务端推送，但Websocket 会更复杂些，且是二进制协议，调 试不方便。AI对话只需要服务器单向推送即可，不需要使用双向通信，所以选择文本格式的SSE。\n项目中，鱼皮的AI问答系统，我直接给包装成了公司项目，反正一个隐私问题，不允许泄密就可以糊弄过去，反正以前我司做过类似项目，各类型都做过，大到给某央企保险公司做，小到大湾区某高校做，正好高校有个AI项目，多一个又何妨?\n说句实话，我司的项目还是比较垃圾，学不到啥东西，做的几乎是CURD和工具类边角料，特别核心的也没接触，所有又学了点鱼皮的项目开始补充自己简历\n3. 代码部分(30min) # 手撕定长缓存，符合LRU，且确保是线程安全的，我就不展示代码，讲讲思路（不对的地方我可以改）（要求用伪代码，怎么写都行，最好按照你擅长的语言来写） 首先，先定义一个带有时间戳的value类 其次，定义这个缓存（我用Map模拟的），这两个成员变量 一个Map\u0026lt;String, Value\u0026gt;缓存 还有个限制容量 最后开始完善写法，有两点注意事项 记得在读取的时候要更新时间，可以把更新时间这部分开另一个线程异步上锁 然后在写的时候记得上锁，这部分才是体现LRU算法的部分 上面全是胡说八道，瞎鸡巴想的，我这里给出参考答案\nLRU缓存: https://www.mianshiya.com/question/1824426914736001026?shareCode=l35fjd\n4. 项目外问题(3min) # Spring的拦截器和过滤器有啥区别（这个一时没答上来） Spring注入Bean的一些方法（举例说明的） QPS和TPS定义（瞎j8答） 瞎聊 5. 你还有什么问题(2min) # 当时和面试官吐槽了一个问题，我以为达摩院的AI和通义家的AI是一套体系，我还说，你们的SDK封装挺难用的（叠个甲，我可不是这么说的，我只是表述这个意思），结果得到的就是它们是两家体系，555\n","date":"2024-11-28","externalUrl":null,"permalink":"/java/interview/epro-od-damo/","section":"Javas","summary":"","title":"易宝软件-外派达摩院AIGC项目组-面试（只有一次/回忆版本）","type":"java"},{"content":" 1. 初始化前情提要 # 此处以：2021.0.5.0 版本为例，Spring Boot 要求：2.6.13 版本\n其余对应组件版本如下\nSentinel Version Nacos Version RocketMQ Version Dubbo Version Seata Version 2021.0.6.0 1.8.6 2.2.0 4.9.4 ~ 1.6.1 2. 项目学习 # 参考：最佳实践示例-阿里云Spring Cloud Alibaba官网\n2.1 微服务的请求流程 # Nacos：集中存管项目中所有服务的信息，便于服务之间找到彼此；同时，还支持集中存储整个项目中的配置。\n2.2 微服务划分（以我的个人项目为例） # 依赖服务 注册中心：Nacos 微服务网关：Gateway，聚合所有接口，统一接受处理前端的请求 公共能力(bbg-backend-common)：异常处理、请求响应封装、AI能力 模型模块(bbg-backend-model)：实体类 公共接口模块(bbg-backend-service-client)：只存放接口，不存放实现 业务模块（详情请参考鱼答答项目） 用户模块(bbg-backend-user-service port:8102) 应用模块(bbg-backend-app-service port:8103) 题目模块(bbg-backend-question-service :8104) 评分模块(bbg-backend-scoring-service :8105) 用户回答模块(bbg-backend-answer-service :8106) 文件模块(bbg-backend-file-service :8107) 2.3 路由划分（以我的个人项目为例，inner代表内部调用，网关层面做限制） # 用户模块(bbg-backend-user-service port:8102): /api/user /api/user/inner 应用模块(含统计，bbg-backend-app-service port:8103): /api/app /api/app/inner 题目模块(bbg-backend-question-service :8104): /api/question /api/question/inner 评分模块(bbg-backend-scoring-service :8105): /api/scoringResult /api/scoringResult/inner 用户答案模块(bbg-backend-answer-service :8106): /api/userAnswer /api/userAnswer/inner 文件模块(bbg-backend-file-service :8107): /api/scoring /api/scoring/inner 2.4 Nacos 服务中心注册 # 官网：Nacos 配置中心简介, Nacos 是什么 | Nacos 官网\n请注意：案例版本中的Nacos对应的是2.2.0，故需要在这里下载Nacos\n安装完毕后，可以配置在环境变量里，以便随时启动Nacos\n2.5 工程新建 # 由于Spring Cloud 依赖众多，参差不齐，不建议随意找配置或手撸\n一定一定要自己积累工程文档，建议脚手架创建项目：Cloud Native App Initializer\n也可以像我一样来配置\n然后按照步骤操作，之后需要在maven中加载一个依赖，否则无法使用\n\u0026lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-dependencies --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2021.0.5\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 然后使用新建模块和Spring Boot初始化脚手架创建各个模块\n接下来绑定子父依赖，确保效果如下：\n以本项目为例，类似这个样子，每个子模块都要有\n\u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.jehol-ppx\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;bbg\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; 项目的pom.xml也要有这个东西\n\u0026lt;modules\u0026gt; \u0026lt;!-- 公共能力部分 --\u0026gt; \u0026lt;module\u0026gt;bbg-backend-common\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;bbg-backend-model\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;bbg-backend-service-client\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;bbg-backend-gateway\u0026lt;/module\u0026gt; \u0026lt;!-- 业务能力部分 --\u0026gt; \u0026lt;module\u0026gt;bbg-backend-user-service\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;bbg-backend-file-service\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;bbg-backend-answer-service\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;bbg-backend-app-service\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;bbg-backend-question-service\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;bbg-backend-scoring-service\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; 这才算大功告成\n子父依赖优势：父模块定义modules，子模块引入parent语法，可以通过继承父模块配置，统一项目的定义和版本号。\n2.6 同步代码\u0026amp;依赖 # 踩个坑：在引入完service-client包的时候，记得把application.propties删除掉，否则一直就是8080\n2.7 服务内部调用 # 现在的问题是，各个模块服务之间相互依赖，但代码已经被分到不同模块中了，无法找到对应的bean，我们需要引入Open Feign来实现跨服务远程调用\n首先，开始梳理项目\n用户模块(bbg-backend-user-service port:8102) 无 应用模块(bbg-backend-app-service port:8103) userService.getById(userId); userService.getUserVO(user); userService.listByIds(userIdSet) \u0026hellip; 题目模块(bbg-backend-question-service :8104) appService.getById(appId); userService.getById(userId); userService.getUserVO(user); userService.listByIds(userIdSet) \u0026hellip; 评分模块(bbg-backend-scoring-service :8105) appService.getById(appId); userService.getById(userId); userService.getUserVO(user); userService.listByIds(userIdSet) \u0026hellip; 用户回答模块(bbg-backend-answer-service :8106) appService.getById(appId); userService.getById(userId); userService.getUserVO(user); userService.listByIds(userIdSet) \u0026hellip; 文件模块(bbg-backend-file-service :8107) userService 接着，确定提供哪些接口\n用户模块(bbg-backend-user-service port:8102) userService.getById(userId); userService.getUserVO(user); userService.listByIds(userIdSet) isAdmin getLoginUser 应用模块(bbg-backend-app-service port:8103) appService.getById(appId); 最后，实现client接口\n开启 openfeign 的支持，把我们的接口暴露出去（服务注册到注册中心上），作为 API 给其他服务调用（其他服务从注册中心寻找) 需要修改每个服务提供者的context-path全局请求路径 服务提供者：理解为接口的实现类，实际提供服务的模块(服务注册到注册中心上) 服务消费者：理解为接口的调用方，需要去找到服务提供者，然后调用。\n注意事项：\n要给接口的每个方法打上请求注解，注意区分Get、Post 要给请求参数打上注解，比如 RequestParam、RequestBody FeignClient定义的请求路径一定要和服务提供方实际的请求路径保持一致 对于用户服务，有一些不利于远程调用参数传递、或者实现起来非常简单（工具类），可以直接用默认方法，无需远程调用，以节约性能 样例代码\npackage com.jeholppx.bbgbackendserviceclient.service; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import com.baomidou.mybatisplus.extension.service.IService; import com.jeholppx.bbgbackendcommon.common.ErrorCode; import com.jeholppx.bbgbackendcommon.constant.UserConstant; import com.jeholppx.bbgbackendcommon.exception.BusinessException; import com.jeholppx.bbgbackendcommon.utils.JWTUtils; import com.jeholppx.bbgbackendmodel.model.dto.user.UserQueryRequest; import com.jeholppx.bbgbackendmodel.model.entity.User; import com.jeholppx.bbgbackendmodel.model.enums.UserRoleEnum; import com.jeholppx.bbgbackendmodel.model.vo.LoginUserVO; import com.jeholppx.bbgbackendmodel.model.vo.UserVO; import org.apache.commons.lang3.StringUtils; import org.springframework.beans.BeanUtils; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; import javax.servlet.http.HttpServletRequest; import java.util.Collection; import java.util.List; import static com.jeholppx.bbgbackendcommon.constant.UserConstant.TOKEN; /** * 用户服务 * * @author \u0026lt;a href=\u0026#34;https://www.jehol-ppx.com\u0026#34;\u0026gt;热河fen青\u0026lt;/a\u0026gt; * @date 2024/10/14 19:00 */ @FeignClient(name = \u0026#34;bbg-backend-user-service\u0026#34;, path = \u0026#34;/api/user/inner\u0026#34;) public interface UserFeignClient { /** * 获取当前登录用户 * * @param request * @return */ default User getLoginUser(HttpServletRequest request) { // 先判断是否已登录 String token = (String) request.getSession().getAttribute(TOKEN); if (StringUtils.isBlank(token)) { throw new BusinessException(ErrorCode.NOT_LOGIN_ERROR); } // 通过token解析用户信息 return (User) JWTUtils.decode(token, User.class); } /** * 是否为管理员 * * @param user * @return */ default boolean isAdmin(User user) { return user != null \u0026amp;\u0026amp; UserRoleEnum.ADMIN.getValue().equals(user.getUserRole()); } /** * 获取脱敏的用户信息 * * @param user * @return */ default UserVO getUserVO(User user) { if (user == null) { return null; } UserVO userVO = new UserVO(); BeanUtils.copyProperties(user, userVO); return userVO; } /** * 获取用户列表 * @param id * @return */ @GetMapping(\u0026#34;/get/id\u0026#34;) User getById(@RequestParam(\u0026#34;userId\u0026#34;) Long id); /** * 获取用户列表 * @param ids * @return */ @GetMapping(\u0026#34;/get/ids\u0026#34;) List\u0026lt;User\u0026gt; listByIds(@RequestParam(\u0026#34;ids\u0026#34;) Collection\u0026lt;Long\u0026gt; ids); } ","date":"2024-10-26","externalUrl":null,"permalink":"/java/spring-cloud/init-spring-cloud/","section":"Javas","summary":"","title":"初始化一个Spring Cloud","type":"java"},{"content":" 1. 什么是微服务 # 1.1 定义 # 微服务是一种软件架构风格，它将一个大型的单体应用程序拆分成多个小的、独立的服务。每个服务都可以独立开发、部署和扩展，并且通常通过轻量级的通信机制（如HTTP或消息队列）进行交互。以下是微服务的一些关键特性：\n独立部署 ：每个微服务可以独立部署，不需要重新部署整个应用程序。 技术多样性 ：不同的微服务可以使用不同的技术栈，根据需要选择最合适的工具和语言。 松耦合 ：微服务之间通过明确的接口进行通信，减少了服务之间的依赖性。 专注单一职责 ：每个微服务专注于完成特定的业务功能，遵循单一职责原则。 弹性和可扩展性 ：可以根据需求独立扩展某个微服务，提高系统的弹性和可扩展性。 微服务架构的优点包括提高开发效率、增强系统的灵活性和可维护性，但也带来了分布式系统的复杂性，如服务发现、负载均衡、分布式事务和监控等问题。\n最好的形容： 一个人的公司，一旦生病，公司随时倒闭 =\u0026gt; 单体服务 多个人的公司，一人生命，公司继续运转不影响 =\u0026gt; 微服务\n1.2 使用场景 # 微服务架构适用于以下场景：\n复杂应用程序 ：当应用程序复杂且包含多个模块时，微服务可以将其拆分为更小的服务，便于管理和开发。 快速迭代 ：需要频繁发布新功能或更新的应用程序，微服务允许独立部署，减少发布周期。 团队规模大 ：大型团队可以根据功能模块划分为多个小团队，每个团队负责一个或多个微服务，减少团队间的依赖。 多样化技术栈 ：不同的服务可以使用不同的技术栈，选择最适合的工具和语言来实现特定功能。 高可扩展性 ：需要高可扩展性的应用程序，可以根据需求独立扩展某个微服务，提高系统的弹性。 高可用性要求 ：通过隔离故障，微服务架构可以提高系统的整体可用性，某个服务的故障不会影响整个系统。 这些场景下，微服务架构能够提供更高的灵活性、可维护性和可扩展性。\n2. 什么是 Spring Cloud # 信息来源：Spring Cloud\nSpring Cloud provides tools for developers to quickly build some of the common patterns in distributed systems (e.g. configuration management, service discovery, circuit breakers, intelligent routing, micro-proxy, control bus, short lived microservices and contract testing). Coordination of distributed systems leads to boiler plate patterns, and using Spring Cloud developers can quickly stand up services and applications that implement those patterns. They will work well in any distributed environment, including the developer’s own laptop, bare metal data centres, and managed platforms such as Cloud Foundry. 翻译后就是：Spring Cloud 为开发人员提供了工具，可以快速构建分布式系统中的一些常见模式（例如配置管理、服务发现、断路器、智能路由、微代理、控制总线、短生命周期微服务和契约测试）。分布式系统的协调会导致样板模式，使用 Spring Cloud，开发人员可以快速启动实现这些模式的服务和应用程序。它们在任何分布式环境中都能很好地工作，包括开发人员自己的笔记本电脑、裸机数据中心和托管平台（如 Cloud Foundry）。\n这段话主要描述了Spring Cloud为开发者提供了一套工具，这些工具可以帮助他们快速构建分布式系统中的一些常见模式。以下是对这段话的详细解释：\nSpring Cloud: 是一个基于Spring Boot的框架，它为微服务架构提供了一系列的解决方案。 tools for developers: Spring Cloud提供的工具，旨在帮助开发者。 quickly build some of the common patterns in distributed systems: 快速构建分布式系统中的常见模式。这些模式是分布式系统中普遍需要解决的问题，Spring Cloud通过提供工具来简化这些问题的解决过程。 e.g.: 举例说明，后面列举了一些分布式系统中的常见模式。 configuration management: 配置管理，指的是集中管理应用和服务的配置信息。 service discovery: 服务发现，允许服务在不知道彼此网络地址的情况下相互发现和通信。 circuit breakers: 断路器模式，防止系统过载的一种机制，当某个服务失败时，断路器可以防止进一步的请求发送到该服务。 intelligent routing: 智能路由，根据当前的系统状态和请求特性，智能地将请求路由到最合适的服务实例。 micro-proxy: 微代理，为微服务提供代理功能，可以进行请求转发、负载均衡等。 control bus: 控制总线，允许开发者在分布式系统中广播消息，用于配置更新、服务协调等。 short lived microservices: 短暂生命周期的微服务，指的是那些生命周期短、需要快速启动和停止的服务。 contract testing: 契约测试，确保服务之间的接口符合预期的约定。 Coordination of distributed systems: 分布式系统的协调，指的是在多个服务和组件之间进行通信和同步。 boiler plate patterns: 模板模式，指的是在构建分布式系统时需要重复使用的代码或模式。 stand up services and applications: 快速搭建服务和应用程序。 work well in any distributed environment: 在任何分布式环境中都能良好工作，包括开发者的个人笔记本电脑、裸机数据中心和像Cloud Foundry这样的托管平台。 总的来说，这段话强调了Spring Cloud如何通过提供一套工具来简化分布式系统开发中的常见问题，使得开发者能够快速构建、部署和运行分布式应用和服务。\n3. Spring Cloud Alibaba 介绍 # 3.0 建议学习官网 # 建议学习官网：Spring Cloud Alibaba官网_基于Springboot的微服务教程-阿里云，尤其要关注版本发布声明，这里有针对不同版本的适配的声明，如 SpringBoot 版本为 2.6.x ，需要使用2021版的相关组件\n一旦发生错误，后果不堪设想\n3.1 什么是Spring Cloud Alibaba # 本章主要来源：Spring Cloud Alibaba 是什么-阿里云Spring Cloud Alibaba官网\nSpring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里分布式应用解决方案，通过阿里中间件来迅速搭建分布式应用系统。此外，Spring Cloud Alibaba 企业版，包括无侵入服务治理(全链路灰度，无损上下线，离群实例摘除等)，企业级 Nacos 注册配置中心和企业级云原生网关等众多产品。\n但对于个人学习来讲，非企业版本即可足够使用\n本质：是在 Spring Cloud 的基础上，进行了增强，补充了一些额外的能力，根据阿里多年的业务沉淀做了一些定制化的开发\n这张图展示了Spring Cloud Alibaba与Spring Cloud的关系，并且详细列出了Spring Cloud Alibaba中的一些核心组件。以下是关于Spring Cloud标准实现和开源产品的详细介绍：\nSpring Cloud 标准实现\nRPC 调用：远程过程调用（Remote Procedure Call, RPC）是一种通信协议，允许在不同计算机上的程序相互调用对方的功能或服务。 服务注册\u0026amp;发现：服务注册与发现是微服务架构中的重要组成部分，用于动态地管理和查找可用的服务实例。 负载均衡：负载均衡是指将网络流量均匀分布到多个服务器上，以提高系统的响应速度和可靠性。 开源产品\nNacos：\nNacos是一个易于使用、功能强大的动态服务发现、配置管理和服务治理平台。 它支持服务注册与发现、分布式配置管理以及服务治理等功能。 Dubbo：\nDubbo是一款高性能、轻量级的开源Java RPC框架，它提供了面向接口的远程方法调用方案。 Dubbo的主要特点是性能高、易用性好、可扩展性强。 RocketMQ：\nRocketMQ是由阿里巴巴开发的一款开源消息中间件，具有高性能、低延迟的特点。 它支持发布/订阅模式的消息传递，适用于大规模分布式系统中的异步通信场景。 Seata：\nSeata是一个开源的分布式事务解决方案，旨在提供高性能和简单易用的分布式事务支持。 它通过全局事务协调器来保证分布式环境下的数据一致性。 Sentinel：\nSentinel是一个开源的流量控制库，主要用于保护后端服务免受大流量冲击。 它可以实时监控应用的入口流量，并根据预设规则进行限流、降级等操作。 Sidecar：\nSidecar模式通常用于微服务架构中，指的是为每个服务部署一个单独的进程，该进程负责处理服务之间的通信和其他辅助任务。 这种模式有助于解耦服务间的依赖关系，提高系统的灵活性和可维护性。 OSS (Object Storage Service)：\nOSS是阿里云提供的对象存储服务，用于存储和检索任意类型的文件。 它提供了高可用性和持久性的存储能力，适合于各种应用场景，如图片、视频、日志等非结构化数据的存储。 Schedulx：\nSchedulx是一个分布式调度平台，用于管理和执行定时任务。 它支持多种触发方式和丰富的任务类型，能够满足企业级应用的需求。 SMS (Short Message Service)：\nSMS模块通常指短信服务，用于发送和接收短信息。 在微服务架构中，它可以作为通知机制的一部分，用于用户认证、订单确认等场景。 这些组件共同构成了Spring Cloud Alibaba的核心功能，帮助开发者构建高效、可靠的微服务应用程序。\n","date":"2024-10-26","externalUrl":null,"permalink":"/java/spring-cloud/what-is-spring-cloud/","section":"Javas","summary":"","title":"微服务简介","type":"java"},{"content":" 0.课前作业 # 编写一个测试程序 # 要求如下\n源码文件以 _test结尾：xxx_test.go 测试方法名以 Test开头 func TestXXX(t *testing.T) { // ... here is your code } 样例代码\npackage try_test import \u0026#34;testing\u0026#34; func TestFirstTry(t *testing.T) { t.Log(\u0026#34;My first try!\u0026#34;) } Go语言赋值(变量定义)特点 # 与其它主要编程语言差异\n赋值可以自动进行类型推断 在一个赋值语句中可以对多个变量进行同时赋值 package fib import ( \u0026#34;fmt\u0026#34; \u0026#34;testing\u0026#34; ) func TestFibTest(t *testing.T) { // 第一种赋值方法 //var a int = 1 //var b int = 1 // 第二种 //var ( // a int = 1 // b = 1 //) // 第三种（推荐） //a := 1 //b := 1 // 假如函数返回值有多个，可以使用 a, b := 1, 1 t.Log(a) for i := 0; i \u0026lt; 5; i++ { t.Log(b) tmp := a a = b b = tmp + a } fmt.Println() } 测试结果\nGOROOT=/usr/local/go #gosetup GOPATH=/Users/jeholppx/go #gosetup /usr/local/go/bin/go test -c -o /Users/jeholppx/Library/Caches/JetBrains/GoLand2023.1/tmp/GoLand/___awesomeProject_src_ch2_fib__TestFibTest.test awesomeProject/src/ch2/fib #gosetup /usr/local/go/bin/go tool test2json -t /Users/jeholppx/Library/Caches/JetBrains/GoLand2023.1/tmp/GoLand/___awesomeProject_src_ch2_fib__TestFibTest.test -test.v -test.paniconexit0 -test.run ^\\QTestFibTest\\E$ === RUN TestFibTest fib_test.go:18: 1 fib_test.go:20: 1 fib_test.go:20: 2 fib_test.go:20: 3 fib_test.go:20: 5 fib_test.go:20: 8 --- PASS: TestFibTest (0.00s) PASS 样例2\n// 包名、引入均省略 func TestExchange(t *testing.T) { a := 1 b := 2 // 常规写法 //tmp := a //a = b //b = tmp // 连续赋值写法 a, b = b, a t.Log(\u0026#34;a =\u0026#34;, a, \u0026#34;b =\u0026#34;, b) } 输出结果\n/usr/local/go/bin/go tool test2json -t /Users/jeholppx/Library/Caches/JetBrains/GoLand2023.1/tmp/GoLand/___awesomeProject_src_ch2_fib__TestExchange.test -test.v -test.paniconexit0 -test.run ^\\QTestExchange\\E$ === RUN TestExchange fib_test.go:36: a = 2 b = 1 --- PASS: TestExchange (0.00s) PASS 常量的定义 # 快速设置连续的const值 # 常规连续值\npackage constant_test import \u0026#34;testing\u0026#34; // go 语言推荐的连续变量写法 const ( Monday = iota + 1 // 1 Tuesday // 2 Wednesday // 3 ) // 也可以像其他语言那样去写 //const ( // Monday = 1 // 1 // Tuesday = 2 // 2 // Wednesday = 3 // 3 //) func TestConstantTry(t *testing.T) { t.Log(Monday, Tuesday) } 测试结果\n=== RUN TestConstantTry constant_test.go:12: 1 2 --- PASS: TestConstantTry (0.00s) PASS 定义一个连续位移，且参与逻辑运算的const值 # // 声明包、导包略 // 连续位移写法 const ( Readable = 1 \u0026lt;\u0026lt; iota // 001 Writeable // 010 Executable // 100 ) func TestConstantTry1(t *testing.T) { a := 7 // 111 t.Log(a\u0026amp;Readable, a\u0026amp;Writeable, a\u0026amp;Executable) // 001 010 100 t.Log(\u0026#34;isReadable:\u0026#34;, a\u0026amp;Readable == Readable) t.Log(\u0026#34;isWriteable:\u0026#34;, a\u0026amp;Writeable == Writeable) t.Log(\u0026#34;isExecutable:\u0026#34;, a\u0026amp;Executable == Executable) } 运行结果\n=== RUN TestConstantTry1 constant_test.go:21: 1 2 4 constant_test.go:22: isReadable: true constant_test.go:23: isWriteable: true constant_test.go:24: isExecutable: true --- PASS: TestConstantTry1 (0.00s) PASS 基本数据类型 # 数据类型分类 # 常见的基本数据类型，可分为以下几类\n布尔型：bool 字符型：string 整型：int int8 int16 int32 int64 无符号整型：uint uint8 uint16 uint32 uint64 uintptr 字节型：byte // alias for uint8 unicode编码值：rune // alias for int32 浮点型：float32 float64 复数型：complex64 complex128 差异 # 与其它主要编程语言的差异\n❌ Golang 不允许隐式类型转换 ❌ 别名与原有类型之间也不能进行隐式转换 错误案例1：隐式变量转换 int to int64\npackage type_test import \u0026#34;testing\u0026#34; func TestImplicit(t *testing.T) { var a int = 1 var b int64 b = a t.Log(a, b) } 运行结果\n# awesomeProject/src/ch3/type_test_test [awesomeProject/src/ch3/type_test.test] ./type_test.go:8:6: cannot use a (variable of type int) as type int64 in assignment 错误案例2：int32 to int64\npackage type_test import \u0026#34;testing\u0026#34; func TestImplicit(t *testing.T) { var a int32 = 1 // 差异点 var b int64 b = a // 修正方案：b = int64(a) t.Log(a, b) } 运行结果\n# awesomeProject/src/ch3/type_test_test [awesomeProject/src/ch3/type_test.test] ./type_test.go:8:6: cannot use a (variable of type int32) as type int64 in assignment 错误用例2修正后\n// ignore package claim and import packages func TestImplicit(t *testing.T) { var a int32 = 1 var b int64 b = int64(a) t.Log(\u0026#34;a =\u0026#34;, a, \u0026#34;b =\u0026#34;, b) } 改进后的错误用例2\n=== RUN TestImplicit type_test.go:11: a = 1 b = 1 --- PASS: TestImplicit (0.00s) PASS 错误用例3：别名与原名类型间的转换\ntype MyInteger int64 func TestImplicit(t *testing.T) { var a int32 = 1 var b int64 b = int64(a) var c MyInteger c = b t.Log(\u0026#34;a =\u0026#34;, a, \u0026#34;b =\u0026#34;, b, \u0026#34;c = \u0026#34;, c) } 运行结果\n# awesomeProject/src/ch3/type_test_test [awesomeProject/src/ch3/type_test.test] ./type_test.go:12:6: cannot use b (variable of type int64) as type MyInteger in assignment 改进方法\nfunc TestImplicit(t *testing.T) { var a int32 = 1 var b int64 b = int64(a) var c MyInteger c = MyInteger(b) // 正解 t.Log(\u0026#34;a =\u0026#34;, a, \u0026#34;b =\u0026#34;, b, \u0026#34;c = \u0026#34;, c) } 运行结果\n=== RUN TestImplicit type_test.go:13: a = 1 b = 1 c = 1 --- PASS: TestImplicit (0.00s) PASS 预定义值 # 以下预定义值很常见，仅举几例\nmath.MaxInt64 math.MaxFloat64 math.MaxUint32 指针类型 # 与C/C++不同的是\n不支持指针运算 string是值类型，其默认初始化值为空字符串，而不是 nil（go语言中, null其实是 nil） 样例1（正例）\nfunc TestPoint(t *testing.T) { a := 1 aPtr := \u0026amp;a t.Log(\u0026#34;a =\u0026#34;, a, \u0026#34;\\nA\u0026#39;s RAM address is\u0026#34;, aPtr) t.Logf(\u0026#34;a type is %T, aPtr type is %T\u0026#34;, a, aPtr) } 运行结果\n=== RUN TestPoint type_test.go:19: a = 1 A\u0026#39;s RAM address is 0x1400010a1d8 type_test.go:20: a type is int, aPtr type is *int --- PASS: TestPoint (0.00s) PASS 到这里会以为和C/C++没什么两样，但是，这样做可以吗？\nfunc TestPoint(t *testing.T) { a := 1 aPtr := \u0026amp;a aPtr = aPtr + 1 // 请判断正误 t.Log(\u0026#34;a =\u0026#34;, a, \u0026#34;\\nA\u0026#39;s RAM address is\u0026#34;, aPtr) t.Logf(\u0026#34;a type is %T, aPtr type is %T\u0026#34;, a, aPtr) } 在判断做法后，看下结果和你预想的是否一样\n# awesomeProject/src/ch3/type_test_test [awesomeProject/src/ch3/type_test.test] ./type_test.go:19:16: cannot convert 1 (untyped int constant) to *int 用例2 字符串\nfunc TestString(t *testing.T) { var s string t.Log(\u0026#34;*\u0026#34; + s + \u0026#34;*\u0026#34;) t.Log(\u0026#34;Is var \\\u0026#34;s\\\u0026#34; an empty-string ?\u0026#34;, s == \u0026#34;\u0026#34;) t.Log(\u0026#34;s longs:\u0026#34;, len(s)) } 运行结果\n=== RUN TestString type_test.go:26: ** type_test.go:27: Is var \u0026#34;s\u0026#34; an empty-string ? true type_test.go:28: s longs: 0 --- PASS: TestString (0.00s) PASS 判断字符串为空，这样可以吗？\nfunc TestString(t *testing.T) { var s string t.Log(\u0026#34;*\u0026#34; + s + \u0026#34;*\u0026#34;) t.Log(\u0026#34;s longs:\u0026#34;, len(s)) // 这样判断可以吗？ if s == nil { t.Log(\u0026#34;s is empty\u0026#34;) } else { t.Log(\u0026#34;s is not empty\u0026#34;) } } 揭晓答案\n# awesomeProject/src/ch3/type_test_test [awesomeProject/src/ch3/type_test.test] ./type_test.go:29:10: invalid operation: s == nil (mismatched types string and untyped nil) 显然这样做是错的，因为string的默认值为空字符串，因此不要这样做\n正解如下：\nfunc TestString(t *testing.T) { var s string t.Log(\u0026#34;*\u0026#34; + s + \u0026#34;*\u0026#34;) t.Log(\u0026#34;s longs:\u0026#34;, len(s)) // 改进如下 if s == \u0026#34;\u0026#34; { t.Log(\u0026#34;s is empty\u0026#34;) } else { t.Log(\u0026#34;s is not empty\u0026#34;) } } 运行结果\n=== RUN TestString type_test.go:30: s is empty --- PASS: TestString (0.00s) PASS 小结和注意事项 # ❌：不允许隐式类型转换，尤其同一种类型的不同别名 ❌：指针类型不可以参与任何运算 ✅：判断字符串是某个值可以直接使用 ==，不为空使用 != ✅：判断字符串为空可以用 str == \u0026quot;\u0026quot;来表示 ❌：不可以用 str == nil判空 ","date":"2024-10-11","externalUrl":null,"permalink":"/golang/golang-basic/chapter-3/","section":"Golangs","summary":"","title":"第三章-变量、常量类型及使用技巧","type":"golang"},{"content":" 1. 环境安装 # 安装Go语言环境在Windows，Linux和Mac上的步骤略有不同。以下是各个操作系统的安装过程：\n要配置Go语言环境的特定版本（例如1.19），你需要执行以下步骤：\n首先，确保已经安装了Go语言环境。你可以通过在终端中运行以下命令来验证安装： go version 如果能够显示已安装的Go版本，则说明安装成功。\n访问Go官方网站（https://golang.org/dl/），并下载所需版本的Go安装程序或安装包。选择与你的操作系统和架构相对应的版本。 安装所下载的Go版本。根据你的操作系统，有以下几种安装方法： Windows: 双击下载的安装程序并按照提示完成安装过程。默认情况下，Go将安装在 C:\\Go目录下。 Linux: 解压下载的安装包到你选择的目录。例如，可以将其解压到 /usr/local目录下： tar -C /usr/local -xzf go1.19.linux-amd64.tar.gz 注意将 go1.19.linux-amd64.tar.gz替换成你下载的安装包的实际文件名。\nMac: 双击下载的安装包并按照提示完成安装过程。默认情况下，Go将安装在 /usr/local/go目录下。 现在，你需要使用环境变量来设置Go的版本和路径。打开你的终端，并执行以下命令： Windows: 在 系统属性 -\u0026gt; 高级 -\u0026gt; 环境变量中，添加一个名为 GOROOT的变量，并将其值设置为Go的安装路径（例如 C:\\Go）。然后，在 Path变量中添加 %GOROOT%\\bin。 Linux和Mac: 使用文本编辑器打开你的 ~/.profile文件或者 ~/.bashrc文件，并添加以下内容： export GOROOT=/usr/local/go export PATH=$PATH:$GOROOT/bin 或者，如果你使用的是Zsh终端，请修改命令为：\n保存并关闭文件，然后在终端中执行以下命令使配置生效： Windows: 关闭并重新打开终端。 Linux和Mac: 在终端中执行以下命令： source ~/.profile 或者\n最后，使用以下命令验证Go的版本和安装是否正确： go version 如果能够显示你安装的Go版本（例如go1.19），则说明配置成功。\n现在，你已经成功配置了Go语言环境的特定版本（1.19），可以开始使用它进行开发了。记得设置好Go的工作路径（GOPATH）和选择一个集成开发环境（IDE）或者文本编辑器进行编码，这里使用Goland。\n2. 编码 # 2.1 准备工作 # 新建一个项目，结构如下\n2.2 编码 # package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 完成以后，在控制台输入指令\ncd src/ch1/main/ go run hello_world.go 显示结果\nHello, World! 如果编译源码，需要另一个指令\ngo build hello_world.go 执行后，可以看到一个可执行程式\nmain \u0026gt; ll total 3784 -rwxr-xr-x@ 1 jeholppx staff 1.8M Jul 9 11:10 hello_world -rw-r--r--@ 1 jeholppx staff 74B Jul 9 11:05 hello_world.go 只要执行这个 hello_world就可以打印上面的结果\n2.3 基本程序结构 # package main // 包，表明代码所在的模块（包） import \u0026#34;fmt\u0026#34; // 引入代码的依赖 // 功能实现 func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 2.4 应用程序入口的标准 # 例程中helloworld是应用程序的入口，作为入口，有以下的基本要求\n必须是main包/模块，声明为 package main，目录名不一定为 main 必须是main方法 func main() 文件名不一定写 main.go，也可以是其他名字 2.4.1 实验 # 新建一个文件夹，拷贝源码，并执行 go run\n# 回到上一级目录 cd .. # 新建一个hello的文件夹 mkdir hello # 复制2.2的源码 cp ./main/hello_world.go ./hello/hello_world.go # 切换文件夹并执行源码 cd ./hello go run hello_world.go 运行结果如下\nHello, World! 如果修改源码\npackage main1 // before is main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 重新运行编译就会提示\npackage command-line-arguments is not a main package 2.5 main函数与其他编程语言的差异 # 2.5.1 返回值方面 # C(++)/Java中：有指定的返回值\nGo语言中\nmain()不支持任何返回值 通过 os.Exit来返回状态 加返回值实验如下\npackage main import \u0026#34;fmt\u0026#34; func main() int { fmt.Println(\u0026#34;Hello, World!\u0026#34;) return 0 } go run hello_world.go # command-line-arguments ./hello_world.go:5:6: func main must have no arguments and no return values 若要返回状态，操作方法如下\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) os.Exit(0) // 返回值 } 这样又可以正常运行了\n当然，返回值也可以定义为一个异常值，如-1\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) os.Exit(-1) // 异常返回 } 运行结果如下\nHello, World! exit status 255 # 异常状态 2.5.2 传参方面 # C++/Java 可以在main函数传参，args string[] 类型\nGo不可以这样做\nmain()本身就不支持传参 需要通过 os.Args()获取参数 程序实例如下\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { args := os.Args fmt.Println(\u0026#34;Hello, World!\u0026#34;) fmt.Println(args) os.Exit(0) } \u0026gt; go run hello_world.go Hello, World! [/var/folders/s5/lh51989j3qv9nrz2p9tdjc8h0000gn/T/go-build3482274569/b001/exe/hello_world] \u0026gt; go run hello_world.go chao Hello, World! [/var/folders/s5/lh51989j3qv9nrz2p9tdjc8h0000gn/T/go-build2433158551/b001/exe/hello_world chao] 第二个例子\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { if len(os.Args) \u0026gt; 1 { fmt.Println(\u0026#34;Hello, World!\u0026#34;, os.Args[1]) } } \u0026gt; go run hello_world.go ppx Hello, World! ppx ","date":"2024-10-11","externalUrl":null,"permalink":"/golang/golang-basic/chapter-2/","section":"Golangs","summary":"","title":"第二章-开始Golang学习","type":"golang"},{"content":"","date":"2024-10-11","externalUrl":null,"permalink":"/tags/go/","section":"Tags","summary":"","title":"Go","type":"tags"},{"content":"","date":"2024-10-11","externalUrl":null,"permalink":"/tags/golang/","section":"Tags","summary":"","title":"Golang","type":"tags"},{"content":"","date":"2024-10-11","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" 1. 前导篇 # 1.1 不同版本的特性 # 参考文章：Go语言各版本特性回顾（1.5-1.14）-腾讯云开发者社区-腾讯云\n1.2 核心特性 # 1.2.1 Go的特性 # 吸收和接纳其他语言的特性 在开发中，能够抓牢程序员的痛点，以简单直接且高效稳定的方式来解决问题 不仅编译迅速，还具有强大的垃圾收集机制和运行反射机制 快速的、静态类型的编译型语言，又有动态类型解释型语言的感觉 表达能力强：简洁清晰高效 思想：大道至简，小而蕴真 1.2.2 核心特性1-并发编程 # 在当今这个时代，并发编程的意义不言而喻，因此Golang具有以下并发编程特点\n简洁程度要胜过绝大多数语言，这是最大的亮点之一，他也是未来进入高并发高性能场景的重要筹码 不同于传统的多进程和多线程，golang的并发执行单元是一种称为goroutine的协程，语言级别关键字 go用于启动协程，并且在同一台机器上启动成千上百个协程；协程间一般由应用程序显示调度，上下文切换无需下到内核层，使得更加高效，通信靠独有的channel机制实现 1.2.3 内存回收(GC) # 内存自动回收，再也不需要开发人员管理内存。回收过程如下： 首先stop the world, 扫描所有对象判活，把可回收对象在一段bitmap区中标记下来 接着立即start the world，回复服务，同时启动一个专门的gorountine，回收内存到空闲list中以备复用 开发人员专注业务实现，降低心智负担 只需要new分配内存，无需物理释放(它由专门线程顶起来执行)； GC瓶颈在于每次都要扫描所有对象来判活，带收集对象越多，速度越慢；其性能会随版本更新而不断优化 1.2.4 内存分配 # 先分配一块大内存区域 大内存被分成各个大小等级的块，放入不同的空闲list中 对象分配空闲时从空闲list中取出大小合适的内存块 内存回收时，会把不用的内存重放会空闲list 空闲内存机制按照一定策略合并，以减少碎片 1.2.5 编译 # 目前Golang具有两种编译器\nGccgo，建立在GCC基础之上 另一种是针对x64和x86计算机的一套编译器(6g和8g) 依赖管理，在代码中的 import中加上github路径即可，库默认下载到pkg目录上 编译时默认会检查代码中所有尸体的使用情况，凡是没用到的package或变量，一定会编译不通过；这确保了go语言的严谨性 1.2.6 网络编程 # Go语言诞生在互联网时代，故天生就具有去中心化、分布式等特性，其中一个具体表现就是提供了丰富的网络编程接口\nsocket用 net.Dial(基于TCP/UDP，封装了传统的 connect``listen``accept等接口) http用 http.Get()或 http.Post() rpc用 client.Call('class_name.method_name', args, \u0026amp;reply) 重要能力：自带高性能HttpServer，通过几行代码就可以得到一个基于协程的高性能Web服务，更重要的是，维护成本极低，没有任何依赖 1.2.7 函数多返回值 # 这个是Go语言与其他传统语言在函数方面上的其中一个区别\n允许函数返回多个值，在某些场景下，可以有效简化编程 由于其官方推荐在函数返回的最后一个参数为error类（只要在逻辑中体现异常），这才有必要要求允许返回多个值 1.2.8 语言交互性 # 定义：本语言是否可以和其他语言交互，比如可以调用其他语言编译的库 Go可以与C程序交互，交互工具叫Cgo，它还可以允许开发者混合编写C语言代码，然后Cgo工具可以把混写的代码提取并生成对于C功能的调用包装代码，开发者可以完全忽略而这边界如何跨越的 1.2.9 异常处理 # 为防止代码量增加以及被滥用（不管多小的异常都要抛出），Go不支持 try ... catch 块，Go处理方式为 defer...recover...panic\ndefer：函数结束后执行，呈先进后出 panic：程序出现无法修复的错误时使用，但defer要执行完，如除以0 recover：会修复错误，不至于程序种植，如果不确定函数会不会出错，就用defer+recover 若异常严重，由Go语言内部自动抛出，用户无需抛出，如果使用 panic(str)就会退化到try-catch块那种模式 1.2.10 其他特性 # 类的推导，可以用var来定义变量（注意：虽然可以用var，但Go毕竟是强类型语言） interface，一个类型只要实现了某个interface的所有方法，即可实现该interface，无需显示继承；Go编程规范推荐每个接口类只提供1-2个方法，这样使每个接口类的目的非常清晰 defer：Go语言关键字，可通过它指定需要延迟执行的逻辑体（在函数体return前或出现panic执行），这种机制适合善后逻辑处理（如资源泄露） \u0026ldquo;包\u0026quot;的概念：和python相同，把相同功能代码放到一个目录，称之为包，包可以被其他包引用，每个程序只有一个main包供其执行 交叉编译：不受系统限制 ","date":"2024-10-11","externalUrl":null,"permalink":"/golang/golang-basic/chapter-1/","section":"Golangs","summary":"","title":"第一章-Golang简介","type":"golang"},{"content":"","date":"2024-10-11","externalUrl":null,"permalink":"/tags/%E5%9F%BA%E7%A1%80/","section":"Tags","summary":"","title":"基础","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]